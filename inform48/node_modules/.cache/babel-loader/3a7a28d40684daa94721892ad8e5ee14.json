{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Boundary } from \"../../common/boundary\";\nimport * as Classes from \"../../common/classes\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n\nvar OverflowList =\n/** @class */\nfunction (_super) {\n  __extends(OverflowList, _super);\n\n  function OverflowList() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      chopSize: _this.defaultChopSize(),\n      lastChopSize: null,\n      lastOverflowCount: 0,\n      overflow: [],\n      repartitioning: false,\n      visible: _this.props.items\n    };\n    _this.spacer = null;\n\n    _this.resize = function () {\n      _this.repartition();\n    };\n\n    return _this;\n  }\n\n  OverflowList.ofType = function () {\n    return OverflowList;\n  };\n\n  OverflowList.prototype.componentDidMount = function () {\n    this.repartition();\n  };\n\n  OverflowList.prototype.shouldComponentUpdate = function (_nextProps, nextState) {\n    // We want this component to always re-render, even when props haven't changed, so that\n    // changes in the renderers' behavior can be reflected.\n    // The following statement prevents re-rendering only in the case where the state changes\n    // identity (i.e. setState was called), but the state is still the same when\n    // shallow-compared to the previous state.\n    return !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n  };\n\n  OverflowList.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b;\n\n    if (prevProps.observeParents !== this.props.observeParents) {\n      console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n    }\n\n    if (prevProps.collapseFrom !== this.props.collapseFrom || prevProps.items !== this.props.items || prevProps.minVisibleItems !== this.props.minVisibleItems || prevProps.overflowRenderer !== this.props.overflowRenderer || prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow || prevProps.visibleItemRenderer !== this.props.visibleItemRenderer) {\n      // reset visible state if the above props change.\n      this.setState({\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        lastOverflowCount: 0,\n        overflow: [],\n        repartitioning: true,\n        visible: this.props.items\n      });\n    }\n\n    var _c = this.state,\n        repartitioning = _c.repartitioning,\n        overflow = _c.overflow,\n        lastOverflowCount = _c.lastOverflowCount;\n\n    if ( // if a resize operation has just completed\n    repartitioning === false && prevState.repartitioning === true) {\n      // only invoke the callback if the UI has actually changed\n      if (overflow.length !== lastOverflowCount) {\n        (_b = (_a = this.props).onOverflow) === null || _b === void 0 ? void 0 : _b.call(_a, overflow.slice());\n      }\n    } else if (!shallowCompareKeys(prevState, this.state)) {\n      this.repartition();\n    }\n  };\n\n  OverflowList.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        className = _a.className,\n        collapseFrom = _a.collapseFrom,\n        observeParents = _a.observeParents,\n        style = _a.style,\n        _b = _a.tagName,\n        tagName = _b === void 0 ? \"div\" : _b,\n        visibleItemRenderer = _a.visibleItemRenderer;\n    var overflow = this.maybeRenderOverflow();\n    var list = React.createElement(tagName, {\n      className: classNames(Classes.OVERFLOW_LIST, className),\n      style: style\n    }, collapseFrom === Boundary.START ? overflow : null, this.state.visible.map(visibleItemRenderer), collapseFrom === Boundary.END ? overflow : null, React.createElement(\"div\", {\n      className: Classes.OVERFLOW_LIST_SPACER,\n      ref: function ref(_ref) {\n        return _this.spacer = _ref;\n      }\n    }));\n    return React.createElement(ResizeSensor, {\n      onResize: this.resize,\n      observeParents: observeParents\n    }, list);\n  };\n\n  OverflowList.prototype.maybeRenderOverflow = function () {\n    var overflow = this.state.overflow;\n\n    if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {\n      return null;\n    }\n\n    return this.props.overflowRenderer(overflow.slice());\n  };\n\n  OverflowList.prototype.repartition = function () {\n    var _this = this;\n\n    var _a;\n\n    if (this.spacer == null) {\n      return;\n    } // if lastChopSize was 1, then our binary search has exhausted.\n\n\n    var partitionExhausted = this.state.lastChopSize === 1;\n    var minVisible = (_a = this.props.minVisibleItems) !== null && _a !== void 0 ? _a : 0; // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n\n    var shouldShrink = this.spacer.offsetWidth < 0.9 && this.state.visible.length > minVisible; // we only check partitionExhausted for shouldGrow to ensure shrinking is the final operation.\n\n    var shouldGrow = (this.spacer.offsetWidth >= 1 || this.state.visible.length < minVisible) && this.state.overflow.length > 0 && !partitionExhausted;\n\n    if (shouldShrink || shouldGrow) {\n      this.setState(function (state) {\n        var visible;\n        var overflow;\n\n        if (_this.props.collapseFrom === Boundary.END) {\n          var result = shiftElements(state.visible, state.overflow, _this.state.chopSize * (shouldShrink ? 1 : -1));\n          visible = result[0];\n          overflow = result[1];\n        } else {\n          var result = shiftElements(state.overflow, state.visible, _this.state.chopSize * (shouldShrink ? -1 : 1));\n          overflow = result[0];\n          visible = result[1];\n        }\n\n        return {\n          chopSize: halve(state.chopSize),\n          lastChopSize: state.chopSize,\n          // if we're starting a new partition cycle, record the last overflow count so we can track whether the UI changes after the new overflow is calculated\n          lastOverflowCount: _this.isFirstPartitionCycle(state.chopSize) ? state.overflow.length : state.lastOverflowCount,\n          overflow: overflow,\n          repartitioning: true,\n          visible: visible\n        };\n      });\n    } else {\n      // repartition complete!\n      this.setState({\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        repartitioning: false\n      });\n    }\n  };\n\n  OverflowList.prototype.defaultChopSize = function () {\n    return halve(this.props.items.length);\n  };\n\n  OverflowList.prototype.isFirstPartitionCycle = function (currentChopSize) {\n    return currentChopSize === this.defaultChopSize();\n  };\n\n  OverflowList.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".OverflowList\");\n  OverflowList.defaultProps = {\n    alwaysRenderOverflow: false,\n    collapseFrom: Boundary.START,\n    minVisibleItems: 0\n  };\n  return OverflowList;\n}(React.Component);\n\nexport { OverflowList };\n\nfunction halve(num) {\n  return Math.ceil(num / 2);\n}\n\nfunction shiftElements(leftArray, rightArray, num) {\n  // if num is positive then elements are shifted from left-to-right, if negative then right-to-left\n  var allElements = leftArray.concat(rightArray);\n  var newLeftLength = leftArray.length - num;\n\n  if (newLeftLength <= 0) {\n    return [[], allElements];\n  } else if (newLeftLength >= allElements.length) {\n    return [allElements, []];\n  }\n\n  var sliceIndex = allElements.length - newLeftLength;\n  return [allElements.slice(0, -sliceIndex), allElements.slice(-sliceIndex)];\n}","map":null,"metadata":{},"sourceType":"module"}