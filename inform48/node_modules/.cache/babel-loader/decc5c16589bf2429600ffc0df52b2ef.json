{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent2, Classes as CoreClasses, DISPLAYNAME_PREFIX, Keys, mergeRefs, Overlay, refHandler, Utils } from \"@blueprintjs/core\";\nimport * as Classes from \"./classes\";\nimport { matchReferenceWidthModifier } from \"./customModifiers\";\nimport * as Errors from \"./errors\";\nimport { Popover2Arrow, POPOVER_ARROW_SVG_SIZE } from \"./popover2Arrow\";\nimport { positionToPlacement } from \"./popover2PlacementUtils\";\nimport { ResizeSensor2 } from \"./resizeSensor2\"; // eslint-disable-next-line import/no-cycle\n\nimport { Tooltip2 } from \"./tooltip2\";\nimport { getBasePlacement, getTransformOrigin } from \"./utils\";\nexport var Popover2InteractionKind = {\n  CLICK: \"click\",\n  CLICK_TARGET_ONLY: \"click-target\",\n  HOVER: \"hover\",\n  HOVER_TARGET_ONLY: \"hover-target\"\n};\n/**\n * @template T target component props interface\n */\n\nvar Popover2 =\n/** @class */\nfunction (_super) {\n  __extends(Popover2, _super);\n\n  function Popover2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      hasDarkParent: false,\n      isOpen: _this.getIsOpen(_this.props)\n    };\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     */\n\n    _this.popoverElement = null;\n    /** DOM element that contains the target. */\n\n    _this.targetElement = null;\n    /** Popover ref handler */\n\n    _this.popoverRef = refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n    /** Target ref handler */\n\n    _this.targetRef = function (el) {\n      return _this.targetElement = el;\n    }; // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n\n\n    _this.isMouseInTargetOrPopover = false; // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n\n    _this.lostFocusOnSamePage = true;\n\n    _this.isControlled = function () {\n      return _this.props.isOpen !== undefined;\n    }; // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n\n\n    _this.isArrowEnabled = function () {\n      var _a, _b;\n\n      return !_this.props.minimal && ((_b = (_a = _this.props.modifiers) === null || _a === void 0 ? void 0 : _a.arrow) === null || _b === void 0 ? void 0 : _b.enabled) !== false;\n    };\n\n    _this.isHoverInteractionKind = function () {\n      return _this.props.interactionKind === Popover2InteractionKind.HOVER || _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY;\n    };\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n\n\n    _this.reposition = function () {\n      var _a;\n\n      return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this);\n    };\n\n    _this.renderTarget = function (_a) {\n      var _b, _c;\n\n      var _d, _e;\n\n      var popperChildRef = _a.ref;\n      var _f = _this.props,\n          children = _f.children,\n          className = _f.className,\n          fill = _f.fill,\n          openOnTargetFocus = _f.openOnTargetFocus,\n          renderTarget = _f.renderTarget;\n      var isOpen = _this.state.isOpen;\n\n      var isControlled = _this.isControlled();\n\n      var isHoverInteractionKind = _this.isHoverInteractionKind();\n\n      var targetTagName = _this.props.targetTagName;\n\n      if (fill) {\n        targetTagName = \"div\";\n      }\n\n      var ref = mergeRefs(popperChildRef, _this.targetRef);\n      var targetEventHandlers = isHoverInteractionKind ? {\n        // HOVER handlers\n        onBlur: _this.handleTargetBlur,\n        onContextMenu: _this.handleTargetContextMenu,\n        onFocus: _this.handleTargetFocus,\n        onMouseEnter: _this.handleMouseEnter,\n        onMouseLeave: _this.handleMouseLeave\n      } : {\n        // CLICK needs only one handler\n        onClick: _this.handleTargetClick,\n        // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n        onKeyDown: function onKeyDown(event) {\n          // eslint-disable-next-line deprecation/deprecation\n          return Keys.isKeyboardClick(event.keyCode) && _this.handleTargetClick(event);\n        }\n      }; // Ensure target is focusable if relevant prop enabled\n\n      var targetTabIndex = openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n\n      var targetProps = __assign({\n        \"aria-haspopup\": (_d = _this.props.popupKind) !== null && _d !== void 0 ? _d : _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY ? undefined : \"true\",\n        // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n        // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n        // applied to the generated target wrapper element.\n        className: classNames(className, Classes.POPOVER2_TARGET, (_b = {}, _b[Classes.POPOVER2_OPEN] = isOpen, // this class is mainly useful for button targets\n        _b[CoreClasses.ACTIVE] = !isControlled && isOpen && !isHoverInteractionKind, _b)),\n        ref: ref\n      }, targetEventHandlers);\n\n      var target;\n\n      if (renderTarget !== undefined) {\n        target = renderTarget(__assign(__assign({}, targetProps), {\n          // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n          // when *this* popover is open\n          isOpen: isOpen,\n          tabIndex: targetTabIndex\n        }));\n      } else {\n        var childTarget = Utils.ensureElement(React.Children.toArray(children)[0]);\n\n        if (childTarget === undefined) {\n          return null;\n        }\n\n        var targetModifierClasses = (_c = {}, // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n        // uncontrolled popovers when they are opened by a user interaction\n        _c[CoreClasses.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind, // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n        _c[CoreClasses.FILL] = fill, _c);\n        var clonedTarget = React.cloneElement(childTarget, {\n          className: classNames(childTarget.props.className, targetModifierClasses),\n          // force disable single Tooltip2 child when popover is open\n          disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip2) ? true : childTarget.props.disabled,\n          tabIndex: (_e = childTarget.props.tabIndex) !== null && _e !== void 0 ? _e : targetTabIndex\n        });\n        var wrappedTarget = React.createElement(targetTagName, targetProps, clonedTarget);\n        target = wrappedTarget;\n      }\n\n      return React.createElement(ResizeSensor2, {\n        targetRef: ref,\n        onResize: _this.reposition\n      }, target);\n    };\n\n    _this.renderPopover = function (popperProps) {\n      var _a;\n\n      var _b;\n\n      var _c = _this.props,\n          interactionKind = _c.interactionKind,\n          shouldReturnFocusOnClose = _c.shouldReturnFocusOnClose,\n          usePortal = _c.usePortal;\n      var isOpen = _this.state.isOpen; // compute an appropriate transform origin so the scale animation points towards target\n\n      var transformOrigin = getTransformOrigin(popperProps.placement, _this.isArrowEnabled() ? popperProps.arrowProps.style : undefined); // need to update our reference to this function on every render as it will change.\n\n      _this.popperScheduleUpdate = popperProps.update;\n      var popoverHandlers = {\n        // always check popover clicks for dismiss class\n        onClick: _this.handlePopoverClick,\n        // treat ENTER/SPACE keys the same as a click for accessibility\n        // eslint-disable-next-line deprecation/deprecation\n        onKeyDown: function onKeyDown(event) {\n          return Keys.isKeyboardClick(event.keyCode) && _this.handlePopoverClick(event);\n        }\n      };\n\n      if (interactionKind === Popover2InteractionKind.HOVER || !usePortal && interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY) {\n        popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n        popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n      }\n\n      var basePlacement = getBasePlacement(popperProps.placement);\n      var popoverClasses = classNames(Classes.POPOVER2, (_a = {}, _a[CoreClasses.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent, _a[CoreClasses.MINIMAL] = _this.props.minimal, _a[Classes.POPOVER2_CAPTURING_DISMISS] = _this.props.captureDismiss, _a[Classes.POPOVER2_MATCH_TARGET_WIDTH] = _this.props.matchTargetWidth, _a[Classes.POPOVER2_REFERENCE_HIDDEN] = popperProps.isReferenceHidden === true, _a[Classes.POPOVER2_POPPER_ESCAPED] = popperProps.hasPopperEscaped === true, _a), \"\".concat(Classes.POPOVER2_CONTENT_PLACEMENT, \"-\").concat(basePlacement), _this.props.popoverClassName);\n      var defaultAutoFocus = _this.isHoverInteractionKind() ? false : undefined;\n      return React.createElement(Overlay, {\n        autoFocus: (_b = _this.props.autoFocus) !== null && _b !== void 0 ? _b : defaultAutoFocus,\n        backdropClassName: Classes.POPOVER2_BACKDROP,\n        backdropProps: _this.props.backdropProps,\n        canEscapeKeyClose: _this.props.canEscapeKeyClose,\n        canOutsideClickClose: _this.props.interactionKind === Popover2InteractionKind.CLICK,\n        enforceFocus: _this.props.enforceFocus,\n        hasBackdrop: _this.props.hasBackdrop,\n        isOpen: isOpen,\n        onClose: _this.handleOverlayClose,\n        onClosed: _this.props.onClosed,\n        onClosing: _this.props.onClosing,\n        onOpened: _this.props.onOpened,\n        onOpening: _this.props.onOpening,\n        transitionDuration: _this.props.transitionDuration,\n        transitionName: Classes.POPOVER2,\n        usePortal: _this.props.usePortal,\n        portalClassName: _this.props.portalClassName,\n        portalContainer: _this.props.portalContainer,\n        // if hover interaction, it doesn't make sense to take over focus control\n        shouldReturnFocusOnClose: _this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose\n      }, React.createElement(\"div\", {\n        className: Classes.POPOVER2_TRANSITION_CONTAINER,\n        ref: popperProps.ref,\n        style: popperProps.style\n      }, React.createElement(ResizeSensor2, {\n        onResize: _this.reposition\n      }, React.createElement(\"div\", __assign({\n        className: popoverClasses,\n        style: {\n          transformOrigin: transformOrigin\n        },\n        ref: _this.popoverRef\n      }, popoverHandlers), _this.isArrowEnabled() && React.createElement(Popover2Arrow, {\n        arrowProps: popperProps.arrowProps,\n        placement: popperProps.placement\n      }), React.createElement(\"div\", {\n        className: Classes.POPOVER2_CONTENT\n      }, _this.props.content)))));\n    };\n\n    _this.handleTargetFocus = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n          // ignore this focus event -- the target was already focused but the page itself\n          // lost focus (e.g. due to switching tabs).\n          return;\n        }\n\n        _this.handleMouseEnter(e);\n      }\n    };\n\n    _this.handleTargetBlur = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget != null) {\n          // if the next element to receive focus is within the popover, we'll want to leave the\n          // popover open.\n          if (e.relatedTarget !== _this.popoverElement && !_this.isElementInPopover(e.relatedTarget)) {\n            _this.handleMouseLeave(e);\n          }\n        } else {\n          _this.handleMouseLeave(e);\n        }\n      }\n\n      _this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n\n    _this.handleTargetContextMenu = function (e) {\n      // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n      // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n      if (e.defaultPrevented) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleMouseEnter = function (e) {\n      _this.isMouseInTargetOrPopover = true; // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n      // trigger the mouse leave event, as hovering over the popover shouldn't count.\n\n      if (!_this.props.usePortal && _this.isElementInPopover(e.target) && _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY && !_this.props.openOnTargetFocus) {\n        _this.handleMouseLeave(e);\n      } else if (!_this.props.disabled) {\n        // only begin opening popover when it is enabled\n        _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n      }\n    };\n\n    _this.handleMouseLeave = function (e) {\n      _this.isMouseInTargetOrPopover = false; // wait until the event queue is flushed, because we want to leave the\n      // popover open if the mouse entered the popover immediately after\n      // leaving the target (or vice versa).\n\n      _this.setTimeout(function () {\n        if (_this.isMouseInTargetOrPopover) {\n          return;\n        } // user-configurable closing delay is helpful when moving mouse from target to popover\n\n\n        _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n      });\n    };\n\n    _this.handlePopoverClick = function (e) {\n      var _a, _b, _c, _d;\n\n      var eventTarget = e.target;\n      var eventPopover = eventTarget.closest(\".\".concat(Classes.POPOVER2));\n      var eventPopoverV1 = eventTarget.closest(\".\".concat(CoreClasses.POPOVER));\n\n      var isEventFromSelf = (eventPopover !== null && eventPopover !== void 0 ? eventPopover : eventPopoverV1) === _this.getPopoverElement();\n\n      var isEventPopoverCapturing = (_b = (_a = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER2_CAPTURING_DISMISS)) !== null && _a !== void 0 ? _a : eventPopoverV1 === null || eventPopoverV1 === void 0 ? void 0 : eventPopoverV1.classList.contains(CoreClasses.POPOVER_CAPTURING_DISMISS)) !== null && _b !== void 0 ? _b : false; // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n\n      var dismissElement = eventTarget.closest(\".\".concat(Classes.POPOVER2_DISMISS, \", .\").concat(Classes.POPOVER2_DISMISS_OVERRIDE)); // dismiss selectors from the \"V1\" version of Popover in the core package\n      // we expect these to be rendered by MenuItem, which at this point has no knowledge of Popover2\n      // this can be removed once Popover2 is merged into core in v5.0\n\n      var dismissElementV1 = eventTarget.closest(\".\".concat(CoreClasses.POPOVER_DISMISS, \", .\").concat(CoreClasses.POPOVER_DISMISS_OVERRIDE));\n      var shouldDismiss = (_d = (_c = dismissElement === null || dismissElement === void 0 ? void 0 : dismissElement.classList.contains(Classes.POPOVER2_DISMISS)) !== null && _c !== void 0 ? _c : dismissElementV1 === null || dismissElementV1 === void 0 ? void 0 : dismissElementV1.classList.contains(CoreClasses.POPOVER_DISMISS)) !== null && _d !== void 0 ? _d : false;\n      var isDisabled = eventTarget.closest(\":disabled, .\".concat(CoreClasses.DISABLED)) != null;\n\n      if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleOverlayClose = function (e) {\n      if (_this.targetElement === null || e === undefined) {\n        return;\n      }\n\n      var eventTarget = e.target; // if click was in target, target event listener will handle things, so don't close\n\n      if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleTargetClick = function (e) {\n      // ensure click did not originate from within inline popover before closing\n      if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n        if (_this.props.isOpen == null) {\n          _this.setState(function (prevState) {\n            return {\n              isOpen: !prevState.isOpen\n            };\n          });\n        } else {\n          _this.setOpenState(!_this.props.isOpen, e);\n        }\n      }\n    };\n\n    return _this;\n  } // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n  // so if we want to look at our actual popover element, we need to reach inside a bit\n\n\n  Popover2.prototype.getPopoverElement = function () {\n    var _a;\n\n    return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.querySelector(\".\".concat(Classes.POPOVER2));\n  };\n\n  Popover2.prototype.getIsOpen = function (props) {\n    var _a; // disabled popovers should never be allowed to open.\n\n\n    if (props.disabled) {\n      return false;\n    } else {\n      return (_a = props.isOpen) !== null && _a !== void 0 ? _a : props.defaultIsOpen;\n    }\n  };\n\n  Popover2.prototype.render = function () {\n    var _a = this.props,\n        disabled = _a.disabled,\n        content = _a.content,\n        placement = _a.placement,\n        _b = _a.position,\n        position = _b === void 0 ? \"auto\" : _b,\n        positioningStrategy = _a.positioningStrategy;\n    var isOpen = this.state.isOpen;\n    var isContentEmpty = content == null || typeof content === \"string\" && content.trim() === \"\";\n\n    if (isContentEmpty) {\n      // need to do this check in render(), because `isOpen` is derived from\n      // state, and state can't necessarily be accessed in validateProps.\n      if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n        console.warn(Errors.POPOVER2_WARN_EMPTY_CONTENT);\n      } // just render the target without a content overlay if there is no content to display\n\n\n      return this.renderTarget({\n        ref: noop\n      });\n    }\n\n    return React.createElement(Manager, null, React.createElement(Reference, null, this.renderTarget), React.createElement(Popper, {\n      innerRef: this.popoverRef,\n      placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(position),\n      strategy: positioningStrategy,\n      modifiers: this.getPopperModifiers()\n    }, this.renderPopover));\n  };\n\n  Popover2.prototype.componentDidMount = function () {\n    this.updateDarkParent();\n  };\n\n  Popover2.prototype.componentDidUpdate = function (props, state) {\n    _super.prototype.componentDidUpdate.call(this, props, state);\n\n    this.updateDarkParent();\n    var nextIsOpen = this.getIsOpen(this.props);\n\n    if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n      this.setOpenState(nextIsOpen); // tricky: setOpenState calls setState only if this.props.isOpen is\n      // not controlled, so we need to invoke setState manually here.\n\n      this.setState({\n        isOpen: nextIsOpen\n      });\n    } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n      // special case: close an uncontrolled popover when disabled is set to true\n      this.setOpenState(false);\n    }\n  };\n\n  Popover2.prototype.validateProps = function (props) {\n    if (props.isOpen == null && props.onInteraction != null) {\n      console.warn(Errors.POPOVER2_WARN_UNCONTROLLED_ONINTERACTION);\n    }\n\n    if (props.hasBackdrop && !props.usePortal) {\n      console.warn(Errors.POPOVER2_WARN_HAS_BACKDROP_INLINE);\n    }\n\n    if (props.hasBackdrop && props.interactionKind !== Popover2InteractionKind.CLICK) {\n      console.warn(Errors.POPOVER2_HAS_BACKDROP_INTERACTION);\n    }\n\n    if (props.placement !== undefined && props.position !== undefined) {\n      console.warn(Errors.POPOVER2_WARN_PLACEMENT_AND_POSITION_MUTEX);\n    }\n\n    var childrenCount = React.Children.count(props.children);\n    var hasRenderTargetProp = props.renderTarget !== undefined;\n\n    if (childrenCount === 0 && !hasRenderTargetProp) {\n      console.warn(Errors.POPOVER2_REQUIRES_TARGET);\n    }\n\n    if (childrenCount > 1) {\n      console.warn(Errors.POPOVER2_WARN_TOO_MANY_CHILDREN);\n    }\n\n    if (childrenCount > 0 && hasRenderTargetProp) {\n      console.warn(Errors.POPOVER2_WARN_DOUBLE_TARGET);\n    }\n  };\n\n  Popover2.prototype.getPopperModifiers = function () {\n    var _a, _b, _c, _d;\n\n    var _e = this.props,\n        matchTargetWidth = _e.matchTargetWidth,\n        modifiers = _e.modifiers,\n        modifiersCustom = _e.modifiersCustom;\n    var popperModifiers = [__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"arrow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow), __assign(__assign({\n      name: \"computeStyles\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles), {\n      options: __assign({\n        adaptive: true,\n        // We disable the built-in gpuAcceleration so that\n        // Popper.js will return us easy to interpolate values\n        // (top, left instead of transform: translate3d)\n        // We'll then use these values to generate the needed\n        // css transform values blended with the react-spring values\n        gpuAcceleration: false\n      }, (_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles) === null || _a === void 0 ? void 0 : _a.options)\n    }), __assign(__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"offset\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset), {\n      options: __assign({\n        offset: [0, POPOVER_ARROW_SVG_SIZE / 2]\n      }, (_b = modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset) === null || _b === void 0 ? void 0 : _b.options)\n    }), __assign(__assign({\n      name: \"flip\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_c = modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip) === null || _c === void 0 ? void 0 : _c.options)\n    }), __assign(__assign({\n      name: \"preventOverflow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_d = modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow) === null || _d === void 0 ? void 0 : _d.options)\n    })];\n\n    if (matchTargetWidth) {\n      popperModifiers.push(matchReferenceWidthModifier);\n    }\n\n    if (modifiersCustom !== undefined) {\n      popperModifiers.push.apply(popperModifiers, modifiersCustom);\n    }\n\n    return popperModifiers;\n  }; // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n  // starts a timeout to delay changing the state if a non-zero duration is provided.\n\n\n  Popover2.prototype.setOpenState = function (isOpen, e, timeout) {\n    var _this = this;\n\n    var _a, _b, _c, _d, _e; // cancel any existing timeout because we have new state\n\n\n    (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (timeout !== undefined && timeout > 0) {\n      this.cancelOpenTimeout = this.setTimeout(function () {\n        return _this.setOpenState(isOpen, e);\n      }, timeout);\n    } else {\n      if (this.props.isOpen == null) {\n        this.setState({\n          isOpen: isOpen\n        });\n      } else {\n        (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n      }\n\n      if (!isOpen) {\n        // non-null assertion because the only time `e` is undefined is when in controlled mode\n        // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n        (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n      }\n    }\n  };\n\n  Popover2.prototype.updateDarkParent = function () {\n    if (this.props.usePortal && this.state.isOpen) {\n      var hasDarkParent = this.targetElement != null && this.targetElement.closest(\".\".concat(CoreClasses.DARK)) != null;\n      this.setState({\n        hasDarkParent: hasDarkParent\n      });\n    }\n  };\n\n  Popover2.prototype.isElementInPopover = function (element) {\n    var _a, _b;\n\n    return (_b = (_a = this.getPopoverElement()) === null || _a === void 0 ? void 0 : _a.contains(element)) !== null && _b !== void 0 ? _b : false;\n  };\n\n  Popover2.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Popover2\");\n  Popover2.defaultProps = {\n    boundary: \"clippingParents\",\n    captureDismiss: false,\n    defaultIsOpen: false,\n    disabled: false,\n    fill: false,\n    hasBackdrop: false,\n    hoverCloseDelay: 300,\n    hoverOpenDelay: 150,\n    inheritDarkTheme: true,\n    interactionKind: Popover2InteractionKind.CLICK,\n    matchTargetWidth: false,\n    minimal: false,\n    openOnTargetFocus: true,\n    // N.B. we don't set a default for `placement` or `position` here because that would trigger\n    // a warning in validateProps if the other prop is specified by a user of this component\n    positioningStrategy: \"absolute\",\n    renderTarget: undefined,\n    shouldReturnFocusOnClose: false,\n    targetTagName: \"span\",\n    transitionDuration: 300,\n    usePortal: true\n  };\n  return Popover2;\n}(AbstractPureComponent2);\n\nexport { Popover2 };\n\nfunction noop() {// no-op\n}","map":null,"metadata":{},"sourceType":"module"}