{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent2, Classes as CoreClasses, DISPLAYNAME_PREFIX, Keys, mergeRefs, Overlay, refHandler, Utils } from \"@blueprintjs/core\";\nimport * as Classes from \"./classes\";\nimport { matchReferenceWidthModifier } from \"./customModifiers\";\nimport * as Errors from \"./errors\";\nimport { Popover2Arrow, POPOVER_ARROW_SVG_SIZE } from \"./popover2Arrow\";\nimport { positionToPlacement } from \"./popover2PlacementUtils\";\nimport { ResizeSensor2 } from \"./resizeSensor2\"; // eslint-disable-next-line import/no-cycle\n\nimport { Tooltip2 } from \"./tooltip2\";\nimport { getBasePlacement, getTransformOrigin } from \"./utils\";\nexport var Popover2InteractionKind = {\n  CLICK: \"click\",\n  CLICK_TARGET_ONLY: \"click-target\",\n  HOVER: \"hover\",\n  HOVER_TARGET_ONLY: \"hover-target\"\n};\n/**\n * @template T target component props interface\n */\n\nvar Popover2 =\n/** @class */\nfunction (_super) {\n  __extends(Popover2, _super);\n\n  function Popover2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      hasDarkParent: false,\n      isOpen: _this.getIsOpen(_this.props)\n    };\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     */\n\n    _this.popoverElement = null;\n    /** DOM element that contains the target. */\n\n    _this.targetElement = null;\n    /** Popover ref handler */\n\n    _this.popoverRef = refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n    /** Target ref handler */\n\n    _this.targetRef = function (el) {\n      return _this.targetElement = el;\n    }; // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n\n\n    _this.isMouseInTargetOrPopover = false; // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n\n    _this.lostFocusOnSamePage = true;\n\n    _this.isControlled = function () {\n      return _this.props.isOpen !== undefined;\n    }; // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n\n\n    _this.isArrowEnabled = function () {\n      var _a, _b;\n\n      return !_this.props.minimal && ((_b = (_a = _this.props.modifiers) === null || _a === void 0 ? void 0 : _a.arrow) === null || _b === void 0 ? void 0 : _b.enabled) !== false;\n    };\n\n    _this.isHoverInteractionKind = function () {\n      return _this.props.interactionKind === Popover2InteractionKind.HOVER || _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY;\n    };\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n\n\n    _this.reposition = function () {\n      var _a;\n\n      return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this);\n    };\n\n    _this.renderTarget = function (_a) {\n      var _b, _c;\n\n      var _d, _e;\n\n      var popperChildRef = _a.ref;\n      var _f = _this.props,\n          children = _f.children,\n          className = _f.className,\n          fill = _f.fill,\n          openOnTargetFocus = _f.openOnTargetFocus,\n          renderTarget = _f.renderTarget;\n      var isOpen = _this.state.isOpen;\n\n      var isControlled = _this.isControlled();\n\n      var isHoverInteractionKind = _this.isHoverInteractionKind();\n\n      var targetTagName = _this.props.targetTagName;\n\n      if (fill) {\n        targetTagName = \"div\";\n      }\n\n      var ref = mergeRefs(popperChildRef, _this.targetRef);\n      var targetEventHandlers = isHoverInteractionKind ? {\n        // HOVER handlers\n        onBlur: _this.handleTargetBlur,\n        onContextMenu: _this.handleTargetContextMenu,\n        onFocus: _this.handleTargetFocus,\n        onMouseEnter: _this.handleMouseEnter,\n        onMouseLeave: _this.handleMouseLeave\n      } : {\n        // CLICK needs only one handler\n        onClick: _this.handleTargetClick,\n        // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n        onKeyDown: function (event) {\n          // eslint-disable-next-line deprecation/deprecation\n          return Keys.isKeyboardClick(event.keyCode) && _this.handleTargetClick(event);\n        }\n      }; // Ensure target is focusable if relevant prop enabled\n\n      var targetTabIndex = openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n\n      var targetProps = __assign({\n        \"aria-haspopup\": (_d = _this.props.popupKind) !== null && _d !== void 0 ? _d : _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY ? undefined : \"true\",\n        // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n        // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n        // applied to the generated target wrapper element.\n        className: classNames(className, Classes.POPOVER2_TARGET, (_b = {}, _b[Classes.POPOVER2_OPEN] = isOpen, // this class is mainly useful for button targets\n        _b[CoreClasses.ACTIVE] = !isControlled && isOpen && !isHoverInteractionKind, _b)),\n        ref: ref\n      }, targetEventHandlers);\n\n      var target;\n\n      if (renderTarget !== undefined) {\n        target = renderTarget(__assign(__assign({}, targetProps), {\n          // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n          // when *this* popover is open\n          isOpen: isOpen,\n          tabIndex: targetTabIndex\n        }));\n      } else {\n        var childTarget = Utils.ensureElement(React.Children.toArray(children)[0]);\n\n        if (childTarget === undefined) {\n          return null;\n        }\n\n        var targetModifierClasses = (_c = {}, // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n        // uncontrolled popovers when they are opened by a user interaction\n        _c[CoreClasses.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind, // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n        _c[CoreClasses.FILL] = fill, _c);\n        var clonedTarget = React.cloneElement(childTarget, {\n          className: classNames(childTarget.props.className, targetModifierClasses),\n          // force disable single Tooltip2 child when popover is open\n          disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip2) ? true : childTarget.props.disabled,\n          tabIndex: (_e = childTarget.props.tabIndex) !== null && _e !== void 0 ? _e : targetTabIndex\n        });\n        var wrappedTarget = React.createElement(targetTagName, targetProps, clonedTarget);\n        target = wrappedTarget;\n      }\n\n      return React.createElement(ResizeSensor2, {\n        targetRef: ref,\n        onResize: _this.reposition\n      }, target);\n    };\n\n    _this.renderPopover = function (popperProps) {\n      var _a;\n\n      var _b;\n\n      var _c = _this.props,\n          interactionKind = _c.interactionKind,\n          shouldReturnFocusOnClose = _c.shouldReturnFocusOnClose,\n          usePortal = _c.usePortal;\n      var isOpen = _this.state.isOpen; // compute an appropriate transform origin so the scale animation points towards target\n\n      var transformOrigin = getTransformOrigin(popperProps.placement, _this.isArrowEnabled() ? popperProps.arrowProps.style : undefined); // need to update our reference to this function on every render as it will change.\n\n      _this.popperScheduleUpdate = popperProps.update;\n      var popoverHandlers = {\n        // always check popover clicks for dismiss class\n        onClick: _this.handlePopoverClick,\n        // treat ENTER/SPACE keys the same as a click for accessibility\n        // eslint-disable-next-line deprecation/deprecation\n        onKeyDown: function (event) {\n          return Keys.isKeyboardClick(event.keyCode) && _this.handlePopoverClick(event);\n        }\n      };\n\n      if (interactionKind === Popover2InteractionKind.HOVER || !usePortal && interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY) {\n        popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n        popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n      }\n\n      var basePlacement = getBasePlacement(popperProps.placement);\n      var popoverClasses = classNames(Classes.POPOVER2, (_a = {}, _a[CoreClasses.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent, _a[CoreClasses.MINIMAL] = _this.props.minimal, _a[Classes.POPOVER2_CAPTURING_DISMISS] = _this.props.captureDismiss, _a[Classes.POPOVER2_MATCH_TARGET_WIDTH] = _this.props.matchTargetWidth, _a[Classes.POPOVER2_REFERENCE_HIDDEN] = popperProps.isReferenceHidden === true, _a[Classes.POPOVER2_POPPER_ESCAPED] = popperProps.hasPopperEscaped === true, _a), \"\".concat(Classes.POPOVER2_CONTENT_PLACEMENT, \"-\").concat(basePlacement), _this.props.popoverClassName);\n      var defaultAutoFocus = _this.isHoverInteractionKind() ? false : undefined;\n      return React.createElement(Overlay, {\n        autoFocus: (_b = _this.props.autoFocus) !== null && _b !== void 0 ? _b : defaultAutoFocus,\n        backdropClassName: Classes.POPOVER2_BACKDROP,\n        backdropProps: _this.props.backdropProps,\n        canEscapeKeyClose: _this.props.canEscapeKeyClose,\n        canOutsideClickClose: _this.props.interactionKind === Popover2InteractionKind.CLICK,\n        enforceFocus: _this.props.enforceFocus,\n        hasBackdrop: _this.props.hasBackdrop,\n        isOpen: isOpen,\n        onClose: _this.handleOverlayClose,\n        onClosed: _this.props.onClosed,\n        onClosing: _this.props.onClosing,\n        onOpened: _this.props.onOpened,\n        onOpening: _this.props.onOpening,\n        transitionDuration: _this.props.transitionDuration,\n        transitionName: Classes.POPOVER2,\n        usePortal: _this.props.usePortal,\n        portalClassName: _this.props.portalClassName,\n        portalContainer: _this.props.portalContainer,\n        // if hover interaction, it doesn't make sense to take over focus control\n        shouldReturnFocusOnClose: _this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose\n      }, React.createElement(\"div\", {\n        className: Classes.POPOVER2_TRANSITION_CONTAINER,\n        ref: popperProps.ref,\n        style: popperProps.style\n      }, React.createElement(ResizeSensor2, {\n        onResize: _this.reposition\n      }, React.createElement(\"div\", __assign({\n        className: popoverClasses,\n        style: {\n          transformOrigin: transformOrigin\n        },\n        ref: _this.popoverRef\n      }, popoverHandlers), _this.isArrowEnabled() && React.createElement(Popover2Arrow, {\n        arrowProps: popperProps.arrowProps,\n        placement: popperProps.placement\n      }), React.createElement(\"div\", {\n        className: Classes.POPOVER2_CONTENT\n      }, _this.props.content)))));\n    };\n\n    _this.handleTargetFocus = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n          // ignore this focus event -- the target was already focused but the page itself\n          // lost focus (e.g. due to switching tabs).\n          return;\n        }\n\n        _this.handleMouseEnter(e);\n      }\n    };\n\n    _this.handleTargetBlur = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget != null) {\n          // if the next element to receive focus is within the popover, we'll want to leave the\n          // popover open.\n          if (e.relatedTarget !== _this.popoverElement && !_this.isElementInPopover(e.relatedTarget)) {\n            _this.handleMouseLeave(e);\n          }\n        } else {\n          _this.handleMouseLeave(e);\n        }\n      }\n\n      _this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n\n    _this.handleTargetContextMenu = function (e) {\n      // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n      // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n      if (e.defaultPrevented) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleMouseEnter = function (e) {\n      _this.isMouseInTargetOrPopover = true; // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n      // trigger the mouse leave event, as hovering over the popover shouldn't count.\n\n      if (!_this.props.usePortal && _this.isElementInPopover(e.target) && _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY && !_this.props.openOnTargetFocus) {\n        _this.handleMouseLeave(e);\n      } else if (!_this.props.disabled) {\n        // only begin opening popover when it is enabled\n        _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n      }\n    };\n\n    _this.handleMouseLeave = function (e) {\n      _this.isMouseInTargetOrPopover = false; // wait until the event queue is flushed, because we want to leave the\n      // popover open if the mouse entered the popover immediately after\n      // leaving the target (or vice versa).\n\n      _this.setTimeout(function () {\n        if (_this.isMouseInTargetOrPopover) {\n          return;\n        } // user-configurable closing delay is helpful when moving mouse from target to popover\n\n\n        _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n      });\n    };\n\n    _this.handlePopoverClick = function (e) {\n      var _a, _b, _c, _d;\n\n      var eventTarget = e.target;\n      var eventPopover = eventTarget.closest(\".\".concat(Classes.POPOVER2));\n      var eventPopoverV1 = eventTarget.closest(\".\".concat(CoreClasses.POPOVER));\n\n      var isEventFromSelf = (eventPopover !== null && eventPopover !== void 0 ? eventPopover : eventPopoverV1) === _this.getPopoverElement();\n\n      var isEventPopoverCapturing = (_b = (_a = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER2_CAPTURING_DISMISS)) !== null && _a !== void 0 ? _a : eventPopoverV1 === null || eventPopoverV1 === void 0 ? void 0 : eventPopoverV1.classList.contains(CoreClasses.POPOVER_CAPTURING_DISMISS)) !== null && _b !== void 0 ? _b : false; // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n\n      var dismissElement = eventTarget.closest(\".\".concat(Classes.POPOVER2_DISMISS, \", .\").concat(Classes.POPOVER2_DISMISS_OVERRIDE)); // dismiss selectors from the \"V1\" version of Popover in the core package\n      // we expect these to be rendered by MenuItem, which at this point has no knowledge of Popover2\n      // this can be removed once Popover2 is merged into core in v5.0\n\n      var dismissElementV1 = eventTarget.closest(\".\".concat(CoreClasses.POPOVER_DISMISS, \", .\").concat(CoreClasses.POPOVER_DISMISS_OVERRIDE));\n      var shouldDismiss = (_d = (_c = dismissElement === null || dismissElement === void 0 ? void 0 : dismissElement.classList.contains(Classes.POPOVER2_DISMISS)) !== null && _c !== void 0 ? _c : dismissElementV1 === null || dismissElementV1 === void 0 ? void 0 : dismissElementV1.classList.contains(CoreClasses.POPOVER_DISMISS)) !== null && _d !== void 0 ? _d : false;\n      var isDisabled = eventTarget.closest(\":disabled, .\".concat(CoreClasses.DISABLED)) != null;\n\n      if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleOverlayClose = function (e) {\n      if (_this.targetElement === null || e === undefined) {\n        return;\n      }\n\n      var eventTarget = e.target; // if click was in target, target event listener will handle things, so don't close\n\n      if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleTargetClick = function (e) {\n      // ensure click did not originate from within inline popover before closing\n      if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n        if (_this.props.isOpen == null) {\n          _this.setState(function (prevState) {\n            return {\n              isOpen: !prevState.isOpen\n            };\n          });\n        } else {\n          _this.setOpenState(!_this.props.isOpen, e);\n        }\n      }\n    };\n\n    return _this;\n  } // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n  // so if we want to look at our actual popover element, we need to reach inside a bit\n\n\n  Popover2.prototype.getPopoverElement = function () {\n    var _a;\n\n    return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.querySelector(\".\".concat(Classes.POPOVER2));\n  };\n\n  Popover2.prototype.getIsOpen = function (props) {\n    var _a; // disabled popovers should never be allowed to open.\n\n\n    if (props.disabled) {\n      return false;\n    } else {\n      return (_a = props.isOpen) !== null && _a !== void 0 ? _a : props.defaultIsOpen;\n    }\n  };\n\n  Popover2.prototype.render = function () {\n    var _a = this.props,\n        disabled = _a.disabled,\n        content = _a.content,\n        placement = _a.placement,\n        _b = _a.position,\n        position = _b === void 0 ? \"auto\" : _b,\n        positioningStrategy = _a.positioningStrategy;\n    var isOpen = this.state.isOpen;\n    var isContentEmpty = content == null || typeof content === \"string\" && content.trim() === \"\";\n\n    if (isContentEmpty) {\n      // need to do this check in render(), because `isOpen` is derived from\n      // state, and state can't necessarily be accessed in validateProps.\n      if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n        console.warn(Errors.POPOVER2_WARN_EMPTY_CONTENT);\n      } // just render the target without a content overlay if there is no content to display\n\n\n      return this.renderTarget({\n        ref: noop\n      });\n    }\n\n    return React.createElement(Manager, null, React.createElement(Reference, null, this.renderTarget), React.createElement(Popper, {\n      innerRef: this.popoverRef,\n      placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(position),\n      strategy: positioningStrategy,\n      modifiers: this.getPopperModifiers()\n    }, this.renderPopover));\n  };\n\n  Popover2.prototype.componentDidMount = function () {\n    this.updateDarkParent();\n  };\n\n  Popover2.prototype.componentDidUpdate = function (props, state) {\n    _super.prototype.componentDidUpdate.call(this, props, state);\n\n    this.updateDarkParent();\n    var nextIsOpen = this.getIsOpen(this.props);\n\n    if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n      this.setOpenState(nextIsOpen); // tricky: setOpenState calls setState only if this.props.isOpen is\n      // not controlled, so we need to invoke setState manually here.\n\n      this.setState({\n        isOpen: nextIsOpen\n      });\n    } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n      // special case: close an uncontrolled popover when disabled is set to true\n      this.setOpenState(false);\n    }\n  };\n\n  Popover2.prototype.validateProps = function (props) {\n    if (props.isOpen == null && props.onInteraction != null) {\n      console.warn(Errors.POPOVER2_WARN_UNCONTROLLED_ONINTERACTION);\n    }\n\n    if (props.hasBackdrop && !props.usePortal) {\n      console.warn(Errors.POPOVER2_WARN_HAS_BACKDROP_INLINE);\n    }\n\n    if (props.hasBackdrop && props.interactionKind !== Popover2InteractionKind.CLICK) {\n      console.warn(Errors.POPOVER2_HAS_BACKDROP_INTERACTION);\n    }\n\n    if (props.placement !== undefined && props.position !== undefined) {\n      console.warn(Errors.POPOVER2_WARN_PLACEMENT_AND_POSITION_MUTEX);\n    }\n\n    var childrenCount = React.Children.count(props.children);\n    var hasRenderTargetProp = props.renderTarget !== undefined;\n\n    if (childrenCount === 0 && !hasRenderTargetProp) {\n      console.warn(Errors.POPOVER2_REQUIRES_TARGET);\n    }\n\n    if (childrenCount > 1) {\n      console.warn(Errors.POPOVER2_WARN_TOO_MANY_CHILDREN);\n    }\n\n    if (childrenCount > 0 && hasRenderTargetProp) {\n      console.warn(Errors.POPOVER2_WARN_DOUBLE_TARGET);\n    }\n  };\n\n  Popover2.prototype.getPopperModifiers = function () {\n    var _a, _b, _c, _d;\n\n    var _e = this.props,\n        matchTargetWidth = _e.matchTargetWidth,\n        modifiers = _e.modifiers,\n        modifiersCustom = _e.modifiersCustom;\n    var popperModifiers = [__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"arrow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow), __assign(__assign({\n      name: \"computeStyles\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles), {\n      options: __assign({\n        adaptive: true,\n        // We disable the built-in gpuAcceleration so that\n        // Popper.js will return us easy to interpolate values\n        // (top, left instead of transform: translate3d)\n        // We'll then use these values to generate the needed\n        // css transform values blended with the react-spring values\n        gpuAcceleration: false\n      }, (_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles) === null || _a === void 0 ? void 0 : _a.options)\n    }), __assign(__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"offset\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset), {\n      options: __assign({\n        offset: [0, POPOVER_ARROW_SVG_SIZE / 2]\n      }, (_b = modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset) === null || _b === void 0 ? void 0 : _b.options)\n    }), __assign(__assign({\n      name: \"flip\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_c = modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip) === null || _c === void 0 ? void 0 : _c.options)\n    }), __assign(__assign({\n      name: \"preventOverflow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_d = modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow) === null || _d === void 0 ? void 0 : _d.options)\n    })];\n\n    if (matchTargetWidth) {\n      popperModifiers.push(matchReferenceWidthModifier);\n    }\n\n    if (modifiersCustom !== undefined) {\n      popperModifiers.push.apply(popperModifiers, modifiersCustom);\n    }\n\n    return popperModifiers;\n  }; // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n  // starts a timeout to delay changing the state if a non-zero duration is provided.\n\n\n  Popover2.prototype.setOpenState = function (isOpen, e, timeout) {\n    var _this = this;\n\n    var _a, _b, _c, _d, _e; // cancel any existing timeout because we have new state\n\n\n    (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (timeout !== undefined && timeout > 0) {\n      this.cancelOpenTimeout = this.setTimeout(function () {\n        return _this.setOpenState(isOpen, e);\n      }, timeout);\n    } else {\n      if (this.props.isOpen == null) {\n        this.setState({\n          isOpen: isOpen\n        });\n      } else {\n        (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n      }\n\n      if (!isOpen) {\n        // non-null assertion because the only time `e` is undefined is when in controlled mode\n        // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n        (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n      }\n    }\n  };\n\n  Popover2.prototype.updateDarkParent = function () {\n    if (this.props.usePortal && this.state.isOpen) {\n      var hasDarkParent = this.targetElement != null && this.targetElement.closest(\".\".concat(CoreClasses.DARK)) != null;\n      this.setState({\n        hasDarkParent: hasDarkParent\n      });\n    }\n  };\n\n  Popover2.prototype.isElementInPopover = function (element) {\n    var _a, _b;\n\n    return (_b = (_a = this.getPopoverElement()) === null || _a === void 0 ? void 0 : _a.contains(element)) !== null && _b !== void 0 ? _b : false;\n  };\n\n  Popover2.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Popover2\");\n  Popover2.defaultProps = {\n    boundary: \"clippingParents\",\n    captureDismiss: false,\n    defaultIsOpen: false,\n    disabled: false,\n    fill: false,\n    hasBackdrop: false,\n    hoverCloseDelay: 300,\n    hoverOpenDelay: 150,\n    inheritDarkTheme: true,\n    interactionKind: Popover2InteractionKind.CLICK,\n    matchTargetWidth: false,\n    minimal: false,\n    openOnTargetFocus: true,\n    // N.B. we don't set a default for `placement` or `position` here because that would trigger\n    // a warning in validateProps if the other prop is specified by a user of this component\n    positioningStrategy: \"absolute\",\n    renderTarget: undefined,\n    shouldReturnFocusOnClose: false,\n    targetTagName: \"span\",\n    transitionDuration: 300,\n    usePortal: true\n  };\n  return Popover2;\n}(AbstractPureComponent2);\n\nexport { Popover2 };\n\nfunction noop() {// no-op\n}","map":{"version":3,"mappings":"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","names":["classNames","React","Manager","Popper","Reference","AbstractPureComponent2","Classes","CoreClasses","DISPLAYNAME_PREFIX","Keys","mergeRefs","Overlay","refHandler","Utils","matchReferenceWidthModifier","Errors","Popover2Arrow","POPOVER_ARROW_SVG_SIZE","positionToPlacement","ResizeSensor2","Tooltip2","getBasePlacement","getTransformOrigin","Popover2InteractionKind","CLICK","CLICK_TARGET_ONLY","HOVER","HOVER_TARGET_ONLY","__extends","_this","hasDarkParent","isOpen","getIsOpen","props","popoverRef","targetElement","el","undefined","minimal","modifiers","_a","arrow","_b","enabled","interactionKind","popperScheduleUpdate","popperChildRef","children","className","fill","openOnTargetFocus","renderTarget","state","isControlled","isHoverInteractionKind","targetTagName","ref","targetRef","targetEventHandlers","onBlur","handleTargetBlur","onContextMenu","handleTargetContextMenu","onFocus","handleTargetFocus","onMouseEnter","handleMouseEnter","onMouseLeave","handleMouseLeave","onClick","handleTargetClick","onKeyDown","event","isKeyboardClick","keyCode","targetTabIndex","targetProps","popupKind","_d","POPOVER2_TARGET","POPOVER2_OPEN","ACTIVE","target","tabIndex","childTarget","ensureElement","Children","toArray","targetModifierClasses","_c","FILL","clonedTarget","cloneElement","disabled","isElementOfType","_e","wrappedTarget","createElement","onResize","reposition","popperProps","shouldReturnFocusOnClose","usePortal","transformOrigin","placement","isArrowEnabled","arrowProps","style","update","popoverHandlers","handlePopoverClick","basePlacement","popoverClasses","POPOVER2","DARK","inheritDarkTheme","MINIMAL","POPOVER2_CAPTURING_DISMISS","captureDismiss","POPOVER2_MATCH_TARGET_WIDTH","matchTargetWidth","POPOVER2_REFERENCE_HIDDEN","isReferenceHidden","POPOVER2_POPPER_ESCAPED","hasPopperEscaped","POPOVER2_CONTENT_PLACEMENT","concat","popoverClassName","defaultAutoFocus","autoFocus","backdropClassName","POPOVER2_BACKDROP","backdropProps","canEscapeKeyClose","canOutsideClickClose","enforceFocus","hasBackdrop","onClose","handleOverlayClose","onClosed","onClosing","onOpened","onOpening","transitionDuration","transitionName","portalClassName","portalContainer","POPOVER2_TRANSITION_CONTAINER","POPOVER2_CONTENT","content","e","relatedTarget","lostFocusOnSamePage","popoverElement","isElementInPopover","defaultPrevented","setOpenState","isMouseInTargetOrPopover","hoverOpenDelay","setTimeout","hoverCloseDelay","eventTarget","eventPopover","closest","eventPopoverV1","POPOVER","isEventFromSelf","getPopoverElement","isEventPopoverCapturing","classList","contains","POPOVER_CAPTURING_DISMISS","dismissElement","POPOVER2_DISMISS","POPOVER2_DISMISS_OVERRIDE","dismissElementV1","POPOVER_DISMISS","POPOVER_DISMISS_OVERRIDE","shouldDismiss","isDisabled","DISABLED","elementIsOrContains","nativeEvent","KeyboardEvent","setState","prevState","Popover2","querySelector","defaultIsOpen","position","positioningStrategy","isContentEmpty","trim","isNodeEnv","console","warn","POPOVER2_WARN_EMPTY_CONTENT","noop","innerRef","strategy","getPopperModifiers","renderPopover","updateDarkParent","_super","componentDidUpdate","call","nextIsOpen","onInteraction","POPOVER2_WARN_UNCONTROLLED_ONINTERACTION","POPOVER2_WARN_HAS_BACKDROP_INLINE","POPOVER2_HAS_BACKDROP_INTERACTION","POPOVER2_WARN_PLACEMENT_AND_POSITION_MUTEX","childrenCount","count","hasRenderTargetProp","POPOVER2_REQUIRES_TARGET","POPOVER2_WARN_TOO_MANY_CHILDREN","POPOVER2_WARN_DOUBLE_TARGET","modifiersCustom","popperModifiers","name","computeStyles","options","adaptive","gpuAcceleration","offset","flip","boundary","rootBoundary","preventOverflow","push","apply","timeout","cancelOpenTimeout","element"],"sources":["/home/administrator/Рабочий стол/inform48-react/inform48/node_modules/@blueprintjs/popover2/src/popover2.tsx"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { State as PopperState, PositioningStrategy } from \"@popperjs/core\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Modifier, Popper, PopperChildrenProps, Reference, ReferenceChildrenProps } from \"react-popper\";\n\nimport {\n    AbstractPureComponent2,\n    Classes as CoreClasses,\n    DISPLAYNAME_PREFIX,\n    HTMLDivProps,\n    Keys,\n    mergeRefs,\n    Overlay,\n    refHandler,\n    Utils,\n} from \"@blueprintjs/core\";\n\nimport * as Classes from \"./classes\";\nimport { matchReferenceWidthModifier } from \"./customModifiers\";\nimport * as Errors from \"./errors\";\nimport { Popover2Arrow, POPOVER_ARROW_SVG_SIZE } from \"./popover2Arrow\";\nimport { positionToPlacement } from \"./popover2PlacementUtils\";\nimport { Popover2SharedProps } from \"./popover2SharedProps\";\nimport { PopupKind } from \"./popupKind\";\nimport { ResizeSensor2 } from \"./resizeSensor2\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip2 } from \"./tooltip2\";\nimport { getBasePlacement, getTransformOrigin } from \"./utils\";\n\nexport const Popover2InteractionKind = {\n    CLICK: \"click\" as \"click\",\n    CLICK_TARGET_ONLY: \"click-target\" as \"click-target\",\n    HOVER: \"hover\" as \"hover\",\n    HOVER_TARGET_ONLY: \"hover-target\" as \"hover-target\",\n};\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type Popover2InteractionKind = typeof Popover2InteractionKind[keyof typeof Popover2InteractionKind];\n\n// eslint-disable-next-line deprecation/deprecation\nexport type Popover2Props<TProps = React.HTMLProps<HTMLElement>> = IPopover2Props<TProps>;\n/** @deprecated use Popover2Props */\nexport interface IPopover2Props<TProps = React.HTMLProps<HTMLElement>> extends Popover2SharedProps<TProps> {\n    /**\n     * Whether the popover/tooltip should acquire application focus when it first opens.\n     *\n     * @default true for click interactions, false for hover interactions\n     */\n    autoFocus?: boolean;\n\n    /** HTML props for the backdrop element. Can be combined with `backdropClassName`. */\n    backdropProps?: React.HTMLProps<HTMLDivElement>;\n\n    /**\n     * The content displayed inside the popover.\n     */\n    content?: string | JSX.Element;\n\n    /**\n     * The kind of interaction that triggers the display of the popover.\n     *\n     * @default \"click\"\n     */\n    interactionKind?: Popover2InteractionKind;\n\n    /**\n     * The kind of popup displayed by the popover. This property is ignored if\n     * `interactionKind` is {@link Popover2InteractionKind.HOVER_TARGET_ONLY}.\n     * This controls the `aria-haspopup` attribute of the target element. The\n     * default is \"menu\" (technically, `aria-haspopup` will be set to \"true\",\n     * which is the same as \"menu\", for backwards compatibility).\n     *\n     * @default \"menu\" or undefined\n     */\n    popupKind?: PopupKind;\n\n    /**\n     * Enables an invisible overlay beneath the popover that captures clicks and\n     * prevents interaction with the rest of the document until the popover is\n     * closed. This prop is only available when `interactionKind` is\n     * `PopoverInteractionKind.CLICK`. When popovers with backdrop are opened,\n     * they become focused.\n     *\n     * @default false\n     */\n    hasBackdrop?: boolean;\n\n    /**\n     * Whether the application should return focus to the last active element in the\n     * document after this popover closes.\n     *\n     * This is automatically set to `false` if this is a hover interaction popover.\n     *\n     * If you are attaching a popover _and_ a tooltip to the same target, you must take\n     * care to either disable this prop for the popover _or_ disable the tooltip's\n     * `openOnTargetFocus` prop.\n     *\n     * @default false\n     */\n    shouldReturnFocusOnClose?: boolean;\n\n    /**\n     * Popper.js positioning strategy.\n     *\n     * @see https://popper.js.org/docs/v2/constructors/#strategy\n     * @default \"absolute\"\n     */\n    positioningStrategy?: PositioningStrategy;\n}\n\nexport interface IPopover2State {\n    isOpen: boolean;\n    hasDarkParent: boolean;\n}\n\n/**\n * @template T target component props interface\n */\nexport class Popover2<T> extends AbstractPureComponent2<Popover2Props<T>, IPopover2State> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Popover2`;\n\n    public static defaultProps: Popover2Props = {\n        boundary: \"clippingParents\",\n        captureDismiss: false,\n        defaultIsOpen: false,\n        disabled: false,\n        fill: false,\n        hasBackdrop: false,\n        hoverCloseDelay: 300,\n        hoverOpenDelay: 150,\n        inheritDarkTheme: true,\n        interactionKind: Popover2InteractionKind.CLICK,\n        matchTargetWidth: false,\n        minimal: false,\n        openOnTargetFocus: true,\n        // N.B. we don't set a default for `placement` or `position` here because that would trigger\n        // a warning in validateProps if the other prop is specified by a user of this component\n        positioningStrategy: \"absolute\",\n        renderTarget: undefined as any,\n        shouldReturnFocusOnClose: false,\n        targetTagName: \"span\",\n        transitionDuration: 300,\n        usePortal: true,\n    };\n\n    public state: IPopover2State = {\n        hasDarkParent: false,\n        isOpen: this.getIsOpen(this.props),\n    };\n\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     */\n    public popoverElement: HTMLElement | null = null;\n\n    /** DOM element that contains the target. */\n    public targetElement: HTMLElement | null = null;\n\n    /** Popover ref handler */\n    private popoverRef: React.Ref<HTMLDivElement> = refHandler(this, \"popoverElement\", this.props.popoverRef);\n\n    /** Target ref handler */\n    private targetRef: React.Ref<HTMLElement> = el => (this.targetElement = el);\n\n    private cancelOpenTimeout?: () => void;\n\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    private isMouseInTargetOrPopover = false;\n\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    private lostFocusOnSamePage = true;\n\n    // Reference to the Poppper.scheduleUpdate() function, this changes every time the popper is mounted\n    private popperScheduleUpdate?: () => Promise<Partial<PopperState> | null>;\n\n    private isControlled = () => this.props.isOpen !== undefined;\n\n    // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n    private isArrowEnabled = () => !this.props.minimal && this.props.modifiers?.arrow?.enabled !== false;\n\n    private isHoverInteractionKind = () => {\n        return (\n            this.props.interactionKind === Popover2InteractionKind.HOVER ||\n            this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY\n        );\n    };\n\n    // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n    // so if we want to look at our actual popover element, we need to reach inside a bit\n    private getPopoverElement() {\n        return this.popoverElement?.querySelector(`.${Classes.POPOVER2}`);\n    }\n\n    private getIsOpen(props: Popover2Props<T>) {\n        // disabled popovers should never be allowed to open.\n        if (props.disabled) {\n            return false;\n        } else {\n            return props.isOpen ?? props.defaultIsOpen!;\n        }\n    }\n\n    public render() {\n        const { disabled, content, placement, position = \"auto\", positioningStrategy } = this.props;\n        const { isOpen } = this.state;\n\n        const isContentEmpty = content == null || (typeof content === \"string\" && content.trim() === \"\");\n        if (isContentEmpty) {\n            // need to do this check in render(), because `isOpen` is derived from\n            // state, and state can't necessarily be accessed in validateProps.\n            if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n                console.warn(Errors.POPOVER2_WARN_EMPTY_CONTENT);\n            }\n            // just render the target without a content overlay if there is no content to display\n            return this.renderTarget({ ref: noop });\n        }\n\n        return (\n            <Manager>\n                <Reference>{this.renderTarget}</Reference>\n                <Popper\n                    innerRef={this.popoverRef}\n                    placement={placement ?? positionToPlacement(position)}\n                    strategy={positioningStrategy}\n                    modifiers={this.getPopperModifiers()}\n                >\n                    {this.renderPopover}\n                </Popper>\n            </Manager>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateDarkParent();\n    }\n\n    public componentDidUpdate(props: Popover2Props<T>, state: IPopover2State) {\n        super.componentDidUpdate(props, state);\n        this.updateDarkParent();\n\n        const nextIsOpen = this.getIsOpen(this.props);\n\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n            this.setOpenState(nextIsOpen);\n            // tricky: setOpenState calls setState only if this.props.isOpen is\n            // not controlled, so we need to invoke setState manually here.\n            this.setState({ isOpen: nextIsOpen });\n        } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n            // special case: close an uncontrolled popover when disabled is set to true\n            this.setOpenState(false);\n        }\n    }\n\n    protected validateProps(props: Popover2Props & { children?: React.ReactNode }) {\n        if (props.isOpen == null && props.onInteraction != null) {\n            console.warn(Errors.POPOVER2_WARN_UNCONTROLLED_ONINTERACTION);\n        }\n        if (props.hasBackdrop && !props.usePortal) {\n            console.warn(Errors.POPOVER2_WARN_HAS_BACKDROP_INLINE);\n        }\n        if (props.hasBackdrop && props.interactionKind !== Popover2InteractionKind.CLICK) {\n            console.warn(Errors.POPOVER2_HAS_BACKDROP_INTERACTION);\n        }\n        if (props.placement !== undefined && props.position !== undefined) {\n            console.warn(Errors.POPOVER2_WARN_PLACEMENT_AND_POSITION_MUTEX);\n        }\n\n        const childrenCount = React.Children.count(props.children);\n        const hasRenderTargetProp = props.renderTarget !== undefined;\n\n        if (childrenCount === 0 && !hasRenderTargetProp) {\n            console.warn(Errors.POPOVER2_REQUIRES_TARGET);\n        }\n        if (childrenCount > 1) {\n            console.warn(Errors.POPOVER2_WARN_TOO_MANY_CHILDREN);\n        }\n        if (childrenCount > 0 && hasRenderTargetProp) {\n            console.warn(Errors.POPOVER2_WARN_DOUBLE_TARGET);\n        }\n    }\n\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    public reposition = () => this.popperScheduleUpdate?.();\n\n    private renderTarget = ({ ref: popperChildRef }: ReferenceChildrenProps) => {\n        const { children, className, fill, openOnTargetFocus, renderTarget } = this.props;\n        const { isOpen } = this.state;\n        const isControlled = this.isControlled();\n        const isHoverInteractionKind = this.isHoverInteractionKind();\n\n        let { targetTagName } = this.props;\n        if (fill) {\n            targetTagName = \"div\";\n        }\n\n        const ref = mergeRefs(popperChildRef, this.targetRef);\n\n        const targetEventHandlers = isHoverInteractionKind\n            ? {\n                  // HOVER handlers\n                  onBlur: this.handleTargetBlur,\n                  onContextMenu: this.handleTargetContextMenu,\n                  onFocus: this.handleTargetFocus,\n                  onMouseEnter: this.handleMouseEnter,\n                  onMouseLeave: this.handleMouseLeave,\n              }\n            : {\n                  // CLICK needs only one handler\n                  onClick: this.handleTargetClick,\n                  // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n                  onKeyDown: (event: React.KeyboardEvent<HTMLElement>) =>\n                      // eslint-disable-next-line deprecation/deprecation\n                      Keys.isKeyboardClick(event.keyCode) && this.handleTargetClick(event),\n              };\n        // Ensure target is focusable if relevant prop enabled\n        const targetTabIndex = openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n        const targetProps = {\n            \"aria-haspopup\":\n                this.props.popupKind ??\n                (this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY ? undefined : \"true\"),\n            // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n            // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n            // applied to the generated target wrapper element.\n            className: classNames(className, Classes.POPOVER2_TARGET, {\n                [Classes.POPOVER2_OPEN]: isOpen,\n                // this class is mainly useful for button targets\n                [CoreClasses.ACTIVE]: !isControlled && isOpen && !isHoverInteractionKind,\n            }),\n            ref,\n            ...(targetEventHandlers as unknown as T),\n        };\n\n        let target: JSX.Element | undefined;\n\n        if (renderTarget !== undefined) {\n            target = renderTarget({\n                ...targetProps,\n                // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n                // when *this* popover is open\n                isOpen,\n                tabIndex: targetTabIndex,\n            });\n        } else {\n            const childTarget = Utils.ensureElement(React.Children.toArray(children)[0])!;\n\n            if (childTarget === undefined) {\n                return null;\n            }\n\n            const targetModifierClasses = {\n                // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n                // uncontrolled popovers when they are opened by a user interaction\n                [CoreClasses.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n                // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n                [CoreClasses.FILL]: fill,\n            };\n            const clonedTarget: JSX.Element = React.cloneElement(childTarget, {\n                className: classNames(childTarget.props.className, targetModifierClasses),\n                // force disable single Tooltip2 child when popover is open\n                disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip2) ? true : childTarget.props.disabled,\n                tabIndex: childTarget.props.tabIndex ?? targetTabIndex,\n            });\n            const wrappedTarget = React.createElement(targetTagName!, targetProps, clonedTarget);\n            target = wrappedTarget;\n        }\n\n        return (\n            <ResizeSensor2 targetRef={ref} onResize={this.reposition}>\n                {target}\n            </ResizeSensor2>\n        );\n    };\n\n    private renderPopover = (popperProps: PopperChildrenProps) => {\n        const { interactionKind, shouldReturnFocusOnClose, usePortal } = this.props;\n        const { isOpen } = this.state;\n\n        // compute an appropriate transform origin so the scale animation points towards target\n        const transformOrigin = getTransformOrigin(\n            popperProps.placement,\n            this.isArrowEnabled() ? (popperProps.arrowProps.style as any) : undefined,\n        );\n\n        // need to update our reference to this function on every render as it will change.\n        this.popperScheduleUpdate = popperProps.update;\n\n        const popoverHandlers: HTMLDivProps = {\n            // always check popover clicks for dismiss class\n            onClick: this.handlePopoverClick,\n            // treat ENTER/SPACE keys the same as a click for accessibility\n            // eslint-disable-next-line deprecation/deprecation\n            onKeyDown: event => Keys.isKeyboardClick(event.keyCode) && this.handlePopoverClick(event),\n        };\n        if (\n            interactionKind === Popover2InteractionKind.HOVER ||\n            (!usePortal && interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY)\n        ) {\n            popoverHandlers.onMouseEnter = this.handleMouseEnter;\n            popoverHandlers.onMouseLeave = this.handleMouseLeave;\n        }\n\n        const basePlacement = getBasePlacement(popperProps.placement);\n        const popoverClasses = classNames(\n            Classes.POPOVER2,\n            {\n                [CoreClasses.DARK]: this.props.inheritDarkTheme && this.state.hasDarkParent,\n                [CoreClasses.MINIMAL]: this.props.minimal,\n                [Classes.POPOVER2_CAPTURING_DISMISS]: this.props.captureDismiss,\n                [Classes.POPOVER2_MATCH_TARGET_WIDTH]: this.props.matchTargetWidth,\n                [Classes.POPOVER2_REFERENCE_HIDDEN]: popperProps.isReferenceHidden === true,\n                [Classes.POPOVER2_POPPER_ESCAPED]: popperProps.hasPopperEscaped === true,\n            },\n            `${Classes.POPOVER2_CONTENT_PLACEMENT}-${basePlacement}`,\n            this.props.popoverClassName,\n        );\n\n        const defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;\n\n        return (\n            <Overlay\n                autoFocus={this.props.autoFocus ?? defaultAutoFocus}\n                backdropClassName={Classes.POPOVER2_BACKDROP}\n                backdropProps={this.props.backdropProps}\n                canEscapeKeyClose={this.props.canEscapeKeyClose}\n                canOutsideClickClose={this.props.interactionKind === Popover2InteractionKind.CLICK}\n                enforceFocus={this.props.enforceFocus}\n                hasBackdrop={this.props.hasBackdrop}\n                isOpen={isOpen}\n                onClose={this.handleOverlayClose}\n                onClosed={this.props.onClosed}\n                onClosing={this.props.onClosing}\n                onOpened={this.props.onOpened}\n                onOpening={this.props.onOpening}\n                transitionDuration={this.props.transitionDuration}\n                transitionName={Classes.POPOVER2}\n                usePortal={this.props.usePortal}\n                portalClassName={this.props.portalClassName}\n                portalContainer={this.props.portalContainer}\n                // if hover interaction, it doesn't make sense to take over focus control\n                shouldReturnFocusOnClose={this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose}\n            >\n                <div className={Classes.POPOVER2_TRANSITION_CONTAINER} ref={popperProps.ref} style={popperProps.style}>\n                    <ResizeSensor2 onResize={this.reposition}>\n                        <div\n                            className={popoverClasses}\n                            style={{ transformOrigin }}\n                            ref={this.popoverRef}\n                            {...popoverHandlers}\n                        >\n                            {this.isArrowEnabled() && (\n                                <Popover2Arrow arrowProps={popperProps.arrowProps} placement={popperProps.placement} />\n                            )}\n                            <div className={Classes.POPOVER2_CONTENT}>{this.props.content}</div>\n                        </div>\n                    </ResizeSensor2>\n                </div>\n            </Overlay>\n        );\n    };\n\n    private getPopperModifiers(): ReadonlyArray<Modifier<any>> {\n        const { matchTargetWidth, modifiers, modifiersCustom } = this.props;\n        const popperModifiers: Array<Modifier<any>> = [\n            {\n                enabled: this.isArrowEnabled(),\n                name: \"arrow\",\n                ...modifiers?.arrow,\n            },\n            {\n                name: \"computeStyles\",\n                ...modifiers?.computeStyles,\n                options: {\n                    adaptive: true,\n                    // We disable the built-in gpuAcceleration so that\n                    // Popper.js will return us easy to interpolate values\n                    // (top, left instead of transform: translate3d)\n                    // We'll then use these values to generate the needed\n                    // css transform values blended with the react-spring values\n                    gpuAcceleration: false,\n                    ...modifiers?.computeStyles?.options,\n                },\n            },\n            {\n                enabled: this.isArrowEnabled(),\n                name: \"offset\",\n                ...modifiers?.offset,\n                options: {\n                    offset: [0, POPOVER_ARROW_SVG_SIZE / 2],\n                    ...modifiers?.offset?.options,\n                },\n            },\n            {\n                name: \"flip\",\n                ...modifiers?.flip,\n                options: {\n                    boundary: this.props.boundary,\n                    rootBoundary: this.props.rootBoundary,\n                    ...modifiers?.flip?.options,\n                },\n            },\n            {\n                name: \"preventOverflow\",\n                ...modifiers?.preventOverflow,\n                options: {\n                    boundary: this.props.boundary,\n                    rootBoundary: this.props.rootBoundary,\n                    ...modifiers?.preventOverflow?.options,\n                },\n            },\n        ];\n\n        if (matchTargetWidth) {\n            popperModifiers.push(matchReferenceWidthModifier);\n        }\n\n        if (modifiersCustom !== undefined) {\n            popperModifiers.push(...modifiersCustom);\n        }\n\n        return popperModifiers;\n    }\n\n    private handleTargetFocus = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget == null && !this.lostFocusOnSamePage) {\n                // ignore this focus event -- the target was already focused but the page itself\n                // lost focus (e.g. due to switching tabs).\n                return;\n            }\n            this.handleMouseEnter(e as unknown as React.MouseEvent<HTMLElement>);\n        }\n    };\n\n    private handleTargetBlur = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget != null) {\n                // if the next element to receive focus is within the popover, we'll want to leave the\n                // popover open.\n                if (\n                    e.relatedTarget !== this.popoverElement &&\n                    !this.isElementInPopover(e.relatedTarget as HTMLElement)\n                ) {\n                    this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);\n                }\n            } else {\n                this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);\n            }\n        }\n        this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n\n    private handleTargetContextMenu = (e: React.MouseEvent<HTMLElement>) => {\n        // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n        // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n        if (e.defaultPrevented) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleMouseEnter = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = true;\n\n        // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n        // trigger the mouse leave event, as hovering over the popover shouldn't count.\n        if (\n            !this.props.usePortal &&\n            this.isElementInPopover(e.target as Element) &&\n            this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY &&\n            !this.props.openOnTargetFocus\n        ) {\n            this.handleMouseLeave(e);\n        } else if (!this.props.disabled) {\n            // only begin opening popover when it is enabled\n            this.setOpenState(true, e, this.props.hoverOpenDelay);\n        }\n    };\n\n    private handleMouseLeave = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = false;\n\n        // wait until the event queue is flushed, because we want to leave the\n        // popover open if the mouse entered the popover immediately after\n        // leaving the target (or vice versa).\n        this.setTimeout(() => {\n            if (this.isMouseInTargetOrPopover) {\n                return;\n            }\n            // user-configurable closing delay is helpful when moving mouse from target to popover\n            this.setOpenState(false, e, this.props.hoverCloseDelay);\n        });\n    };\n\n    private handlePopoverClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        const eventTarget = e.target as HTMLElement;\n        const eventPopover = eventTarget.closest(`.${Classes.POPOVER2}`);\n        const eventPopoverV1 = eventTarget.closest(`.${CoreClasses.POPOVER}`);\n        const isEventFromSelf = (eventPopover ?? eventPopoverV1) === this.getPopoverElement();\n\n        const isEventPopoverCapturing =\n            eventPopover?.classList.contains(Classes.POPOVER2_CAPTURING_DISMISS) ??\n            eventPopoverV1?.classList.contains(CoreClasses.POPOVER_CAPTURING_DISMISS) ??\n            false;\n\n        // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n        const dismissElement = eventTarget.closest(\n            `.${Classes.POPOVER2_DISMISS}, .${Classes.POPOVER2_DISMISS_OVERRIDE}`,\n        );\n        // dismiss selectors from the \"V1\" version of Popover in the core package\n        // we expect these to be rendered by MenuItem, which at this point has no knowledge of Popover2\n        // this can be removed once Popover2 is merged into core in v5.0\n        const dismissElementV1 = eventTarget.closest(\n            `.${CoreClasses.POPOVER_DISMISS}, .${CoreClasses.POPOVER_DISMISS_OVERRIDE}`,\n        );\n\n        const shouldDismiss =\n            dismissElement?.classList.contains(Classes.POPOVER2_DISMISS) ??\n            dismissElementV1?.classList.contains(CoreClasses.POPOVER_DISMISS) ??\n            false;\n\n        const isDisabled = eventTarget.closest(`:disabled, .${CoreClasses.DISABLED}`) != null;\n\n        if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleOverlayClose = (e?: React.SyntheticEvent<HTMLElement>) => {\n        if (this.targetElement === null || e === undefined) {\n            return;\n        }\n\n        const eventTarget = e.target as HTMLElement;\n        // if click was in target, target event listener will handle things, so don't close\n        if (!Utils.elementIsOrContains(this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleTargetClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        // ensure click did not originate from within inline popover before closing\n        if (!this.props.disabled && !this.isElementInPopover(e.target as HTMLElement)) {\n            if (this.props.isOpen == null) {\n                this.setState(prevState => ({ isOpen: !prevState.isOpen }));\n            } else {\n                this.setOpenState(!this.props.isOpen, e);\n            }\n        }\n    };\n\n    // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\n    private setOpenState(isOpen: boolean, e?: React.SyntheticEvent<HTMLElement>, timeout?: number) {\n        // cancel any existing timeout because we have new state\n        this.cancelOpenTimeout?.();\n        if (timeout !== undefined && timeout > 0) {\n            this.cancelOpenTimeout = this.setTimeout(() => this.setOpenState(isOpen, e), timeout);\n        } else {\n            if (this.props.isOpen == null) {\n                this.setState({ isOpen });\n            } else {\n                this.props.onInteraction?.(isOpen, e);\n            }\n            if (!isOpen) {\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n                this.props.onClose?.(e!);\n            }\n        }\n    }\n\n    private updateDarkParent() {\n        if (this.props.usePortal && this.state.isOpen) {\n            const hasDarkParent =\n                this.targetElement != null && this.targetElement.closest(`.${CoreClasses.DARK}`) != null;\n            this.setState({ hasDarkParent });\n        }\n    }\n\n    private isElementInPopover(element: Element) {\n        return this.getPopoverElement()?.contains(element) ?? false;\n    }\n}\n\nfunction noop() {\n    // no-op\n}\n"]},"metadata":{},"sourceType":"module"}