{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Boundary } from \"../../common/boundary\";\nimport * as Classes from \"../../common/classes\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n\nvar OverflowList =\n/** @class */\nfunction (_super) {\n  __extends(OverflowList, _super);\n\n  function OverflowList() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      chopSize: _this.defaultChopSize(),\n      lastChopSize: null,\n      lastOverflowCount: 0,\n      overflow: [],\n      repartitioning: false,\n      visible: _this.props.items\n    };\n    _this.spacer = null;\n\n    _this.resize = function () {\n      _this.repartition();\n    };\n\n    return _this;\n  }\n\n  OverflowList.ofType = function () {\n    return OverflowList;\n  };\n\n  OverflowList.prototype.componentDidMount = function () {\n    this.repartition();\n  };\n\n  OverflowList.prototype.shouldComponentUpdate = function (_nextProps, nextState) {\n    // We want this component to always re-render, even when props haven't changed, so that\n    // changes in the renderers' behavior can be reflected.\n    // The following statement prevents re-rendering only in the case where the state changes\n    // identity (i.e. setState was called), but the state is still the same when\n    // shallow-compared to the previous state.\n    return !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n  };\n\n  OverflowList.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b;\n\n    if (prevProps.observeParents !== this.props.observeParents) {\n      console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n    }\n\n    if (prevProps.collapseFrom !== this.props.collapseFrom || prevProps.items !== this.props.items || prevProps.minVisibleItems !== this.props.minVisibleItems || prevProps.overflowRenderer !== this.props.overflowRenderer || prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow || prevProps.visibleItemRenderer !== this.props.visibleItemRenderer) {\n      // reset visible state if the above props change.\n      this.setState({\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        lastOverflowCount: 0,\n        overflow: [],\n        repartitioning: true,\n        visible: this.props.items\n      });\n    }\n\n    var _c = this.state,\n        repartitioning = _c.repartitioning,\n        overflow = _c.overflow,\n        lastOverflowCount = _c.lastOverflowCount;\n\n    if ( // if a resize operation has just completed\n    repartitioning === false && prevState.repartitioning === true) {\n      // only invoke the callback if the UI has actually changed\n      if (overflow.length !== lastOverflowCount) {\n        (_b = (_a = this.props).onOverflow) === null || _b === void 0 ? void 0 : _b.call(_a, overflow.slice());\n      }\n    } else if (!shallowCompareKeys(prevState, this.state)) {\n      this.repartition();\n    }\n  };\n\n  OverflowList.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        className = _a.className,\n        collapseFrom = _a.collapseFrom,\n        observeParents = _a.observeParents,\n        style = _a.style,\n        _b = _a.tagName,\n        tagName = _b === void 0 ? \"div\" : _b,\n        visibleItemRenderer = _a.visibleItemRenderer;\n    var overflow = this.maybeRenderOverflow();\n    var list = React.createElement(tagName, {\n      className: classNames(Classes.OVERFLOW_LIST, className),\n      style: style\n    }, collapseFrom === Boundary.START ? overflow : null, this.state.visible.map(visibleItemRenderer), collapseFrom === Boundary.END ? overflow : null, React.createElement(\"div\", {\n      className: Classes.OVERFLOW_LIST_SPACER,\n      ref: function (ref) {\n        return _this.spacer = ref;\n      }\n    }));\n    return React.createElement(ResizeSensor, {\n      onResize: this.resize,\n      observeParents: observeParents\n    }, list);\n  };\n\n  OverflowList.prototype.maybeRenderOverflow = function () {\n    var overflow = this.state.overflow;\n\n    if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {\n      return null;\n    }\n\n    return this.props.overflowRenderer(overflow.slice());\n  };\n\n  OverflowList.prototype.repartition = function () {\n    var _this = this;\n\n    var _a;\n\n    if (this.spacer == null) {\n      return;\n    } // if lastChopSize was 1, then our binary search has exhausted.\n\n\n    var partitionExhausted = this.state.lastChopSize === 1;\n    var minVisible = (_a = this.props.minVisibleItems) !== null && _a !== void 0 ? _a : 0; // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n\n    var shouldShrink = this.spacer.offsetWidth < 0.9 && this.state.visible.length > minVisible; // we only check partitionExhausted for shouldGrow to ensure shrinking is the final operation.\n\n    var shouldGrow = (this.spacer.offsetWidth >= 1 || this.state.visible.length < minVisible) && this.state.overflow.length > 0 && !partitionExhausted;\n\n    if (shouldShrink || shouldGrow) {\n      this.setState(function (state) {\n        var visible;\n        var overflow;\n\n        if (_this.props.collapseFrom === Boundary.END) {\n          var result = shiftElements(state.visible, state.overflow, _this.state.chopSize * (shouldShrink ? 1 : -1));\n          visible = result[0];\n          overflow = result[1];\n        } else {\n          var result = shiftElements(state.overflow, state.visible, _this.state.chopSize * (shouldShrink ? -1 : 1));\n          overflow = result[0];\n          visible = result[1];\n        }\n\n        return {\n          chopSize: halve(state.chopSize),\n          lastChopSize: state.chopSize,\n          // if we're starting a new partition cycle, record the last overflow count so we can track whether the UI changes after the new overflow is calculated\n          lastOverflowCount: _this.isFirstPartitionCycle(state.chopSize) ? state.overflow.length : state.lastOverflowCount,\n          overflow: overflow,\n          repartitioning: true,\n          visible: visible\n        };\n      });\n    } else {\n      // repartition complete!\n      this.setState({\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        repartitioning: false\n      });\n    }\n  };\n\n  OverflowList.prototype.defaultChopSize = function () {\n    return halve(this.props.items.length);\n  };\n\n  OverflowList.prototype.isFirstPartitionCycle = function (currentChopSize) {\n    return currentChopSize === this.defaultChopSize();\n  };\n\n  OverflowList.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".OverflowList\");\n  OverflowList.defaultProps = {\n    alwaysRenderOverflow: false,\n    collapseFrom: Boundary.START,\n    minVisibleItems: 0\n  };\n  return OverflowList;\n}(React.Component);\n\nexport { OverflowList };\n\nfunction halve(num) {\n  return Math.ceil(num / 2);\n}\n\nfunction shiftElements(leftArray, rightArray, num) {\n  // if num is positive then elements are shifted from left-to-right, if negative then right-to-left\n  var allElements = leftArray.concat(rightArray);\n  var newLeftLength = leftArray.length - num;\n\n  if (newLeftLength <= 0) {\n    return [[], allElements];\n  } else if (newLeftLength >= allElements.length) {\n    return [allElements, []];\n  }\n\n  var sliceIndex = allElements.length - newLeftLength;\n  return [allElements.slice(0, -sliceIndex), allElements.slice(-sliceIndex)];\n}","map":{"version":3,"mappings":"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","names":["classNames","React","Boundary","Classes","OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED","DISPLAYNAME_PREFIX","shallowCompareKeys","ResizeSensor","__extends","_this","chopSize","defaultChopSize","lastChopSize","lastOverflowCount","overflow","repartitioning","visible","props","items","repartition","OverflowList","_nextProps","nextState","state","prevProps","prevState","observeParents","console","warn","collapseFrom","minVisibleItems","overflowRenderer","alwaysRenderOverflow","visibleItemRenderer","setState","length","onOverflow","_b","slice","className","style","tagName","maybeRenderOverflow","list","createElement","OVERFLOW_LIST","START","map","END","OVERFLOW_LIST_SPACER","ref","spacer","onResize","resize","partitionExhausted","minVisible","_a","shouldShrink","offsetWidth","shouldGrow","result","shiftElements","halve","isFirstPartitionCycle","currentChopSize","Component","num","Math","ceil","leftArray","rightArray","allElements","concat","newLeftLength","sliceIndex"],"sources":["/home/administrator/Рабочий стол/inform48-react/inform48/node_modules/@blueprintjs/core/src/components/overflow-list/overflowList.tsx"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { Boundary } from \"../../common/boundary\";\nimport * as Classes from \"../../common/classes\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, Props } from \"../../common/props\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type OverflowListProps<T> = IOverflowListProps<T>;\n/** @deprecated use OverflowListProps */\nexport interface IOverflowListProps<T> extends Props {\n    /**\n     * Whether to force the overflowRenderer to always be called, even if there are zero items\n     * overflowing. This may be useful, for example, if your overflow renderer contains a Popover\n     * which you do not want to close as the list is resized.\n     *\n     * @default false\n     */\n    alwaysRenderOverflow?: boolean;\n\n    /**\n     * Which direction the items should collapse from: start or end of the\n     * children. This also determines whether `overflowRenderer` appears before\n     * (`START`) or after (`END`) the visible items.\n     *\n     * @default Boundary.START\n     */\n    collapseFrom?: Boundary;\n\n    /**\n     * All items to display in the list. Items that do not fit in the container\n     * will be rendered in the overflow instead.\n     */\n    items: readonly T[];\n\n    /**\n     * The minimum number of visible items that should never collapse into the\n     * overflow menu, regardless of DOM dimensions.\n     *\n     * @default 0\n     */\n    minVisibleItems?: number;\n\n    /**\n     * If `true`, all parent DOM elements of the container will also be\n     * observed. If changes to a parent's size is detected, the overflow will be\n     * recalculated.\n     *\n     * Only enable this prop if the overflow should be recalculated when a\n     * parent element resizes in a way that does not also cause the\n     * `OverflowList` to resize.\n     *\n     * @default false\n     */\n    observeParents?: boolean;\n\n    /**\n     * Callback invoked when the overflowed items change. This is called once\n     * after the DOM has settled, rather that on every intermediate change. It\n     * is not invoked if resizing produces an unchanged overflow state.\n     */\n    onOverflow?: (overflowItems: T[]) => void;\n\n    /**\n     * Callback invoked to render the overflowed items. Unlike\n     * `visibleItemRenderer`, this prop is invoked once with all items that do\n     * not fit in the container.\n     *\n     * Typical use cases for this prop will put overflowed items in a dropdown\n     * menu or display a \"+X items\" label.\n     */\n    overflowRenderer: (overflowItems: T[]) => React.ReactNode;\n\n    /** CSS properties to apply to the root element. */\n    style?: React.CSSProperties;\n\n    /**\n     * HTML tag name for the container element.\n     *\n     * @default \"div\"\n     */\n    tagName?: keyof JSX.IntrinsicElements;\n\n    /**\n     * Callback invoked to render each visible item.\n     * Remember to set a `key` on the rendered element!\n     */\n    visibleItemRenderer: (item: T, index: number) => React.ReactChild;\n}\n\nexport interface IOverflowListState<T> {\n    /** Whether repartitioning is still active. An overflow can take several frames to settle. */\n    repartitioning: boolean;\n    /** Length of last overflow to dedupe `onOverflow` calls during smooth resizing. */\n    lastOverflowCount: number;\n    overflow: readonly T[];\n    visible: readonly T[];\n    /** Pointer for the binary search algorithm used to find the finished non-overflowing state */\n    chopSize: number;\n    lastChopSize: number | null;\n}\n\nexport class OverflowList<T> extends React.Component<OverflowListProps<T>, IOverflowListState<T>> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.OverflowList`;\n\n    public static defaultProps: Partial<OverflowListProps<any>> = {\n        alwaysRenderOverflow: false,\n        collapseFrom: Boundary.START,\n        minVisibleItems: 0,\n    };\n\n    public static ofType<U>() {\n        return OverflowList as new (props: OverflowListProps<U>) => OverflowList<U>;\n    }\n\n    public state: IOverflowListState<T> = {\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        lastOverflowCount: 0,\n        overflow: [],\n        repartitioning: false,\n        visible: this.props.items,\n    };\n\n    private spacer: HTMLElement | null = null;\n\n    public componentDidMount() {\n        this.repartition();\n    }\n\n    public shouldComponentUpdate(_nextProps: OverflowListProps<T>, nextState: IOverflowListState<T>) {\n        // We want this component to always re-render, even when props haven't changed, so that\n        // changes in the renderers' behavior can be reflected.\n        // The following statement prevents re-rendering only in the case where the state changes\n        // identity (i.e. setState was called), but the state is still the same when\n        // shallow-compared to the previous state.\n        return !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n    }\n\n    public componentDidUpdate(prevProps: OverflowListProps<T>, prevState: IOverflowListState<T>) {\n        if (prevProps.observeParents !== this.props.observeParents) {\n            console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n        }\n\n        if (\n            prevProps.collapseFrom !== this.props.collapseFrom ||\n            prevProps.items !== this.props.items ||\n            prevProps.minVisibleItems !== this.props.minVisibleItems ||\n            prevProps.overflowRenderer !== this.props.overflowRenderer ||\n            prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow ||\n            prevProps.visibleItemRenderer !== this.props.visibleItemRenderer\n        ) {\n            // reset visible state if the above props change.\n            this.setState({\n                chopSize: this.defaultChopSize(),\n                lastChopSize: null,\n                lastOverflowCount: 0,\n                overflow: [],\n                repartitioning: true,\n                visible: this.props.items,\n            });\n        }\n\n        const { repartitioning, overflow, lastOverflowCount } = this.state;\n\n        if (\n            // if a resize operation has just completed\n            repartitioning === false &&\n            prevState.repartitioning === true\n        ) {\n            // only invoke the callback if the UI has actually changed\n            if (overflow.length !== lastOverflowCount) {\n                this.props.onOverflow?.(overflow.slice());\n            }\n        } else if (!shallowCompareKeys(prevState, this.state)) {\n            this.repartition();\n        }\n    }\n\n    public render() {\n        const { className, collapseFrom, observeParents, style, tagName = \"div\", visibleItemRenderer } = this.props;\n        const overflow = this.maybeRenderOverflow();\n        const list = React.createElement(\n            tagName,\n            {\n                className: classNames(Classes.OVERFLOW_LIST, className),\n                style,\n            },\n            collapseFrom === Boundary.START ? overflow : null,\n            this.state.visible.map(visibleItemRenderer),\n            collapseFrom === Boundary.END ? overflow : null,\n            <div className={Classes.OVERFLOW_LIST_SPACER} ref={ref => (this.spacer = ref)} />,\n        );\n\n        return (\n            <ResizeSensor onResize={this.resize} observeParents={observeParents}>\n                {list}\n            </ResizeSensor>\n        );\n    }\n\n    private maybeRenderOverflow() {\n        const { overflow } = this.state;\n        if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {\n            return null;\n        }\n        return this.props.overflowRenderer(overflow.slice());\n    }\n\n    private resize = () => {\n        this.repartition();\n    };\n\n    private repartition() {\n        if (this.spacer == null) {\n            return;\n        }\n\n        // if lastChopSize was 1, then our binary search has exhausted.\n        const partitionExhausted = this.state.lastChopSize === 1;\n        const minVisible = this.props.minVisibleItems ?? 0;\n\n        // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n        const shouldShrink = this.spacer.offsetWidth < 0.9 && this.state.visible.length > minVisible;\n\n        // we only check partitionExhausted for shouldGrow to ensure shrinking is the final operation.\n        const shouldGrow =\n            (this.spacer.offsetWidth >= 1 || this.state.visible.length < minVisible) &&\n            this.state.overflow.length > 0 &&\n            !partitionExhausted;\n\n        if (shouldShrink || shouldGrow) {\n            this.setState(state => {\n                let visible;\n                let overflow;\n                if (this.props.collapseFrom === Boundary.END) {\n                    const result = shiftElements(\n                        state.visible,\n                        state.overflow,\n                        this.state.chopSize * (shouldShrink ? 1 : -1),\n                    );\n                    visible = result[0];\n                    overflow = result[1];\n                } else {\n                    const result = shiftElements(\n                        state.overflow,\n                        state.visible,\n                        this.state.chopSize * (shouldShrink ? -1 : 1),\n                    );\n                    overflow = result[0];\n                    visible = result[1];\n                }\n\n                return {\n                    chopSize: halve(state.chopSize),\n                    lastChopSize: state.chopSize,\n                    // if we're starting a new partition cycle, record the last overflow count so we can track whether the UI changes after the new overflow is calculated\n                    lastOverflowCount: this.isFirstPartitionCycle(state.chopSize)\n                        ? state.overflow.length\n                        : state.lastOverflowCount,\n                    overflow,\n                    repartitioning: true,\n                    visible,\n                };\n            });\n        } else {\n            // repartition complete!\n            this.setState({\n                chopSize: this.defaultChopSize(),\n                lastChopSize: null,\n                repartitioning: false,\n            });\n        }\n    }\n\n    private defaultChopSize(): number {\n        return halve(this.props.items.length);\n    }\n\n    private isFirstPartitionCycle(currentChopSize: number): boolean {\n        return currentChopSize === this.defaultChopSize();\n    }\n}\n\nfunction halve(num: number): number {\n    return Math.ceil(num / 2);\n}\n\nfunction shiftElements<T>(leftArray: readonly T[], rightArray: readonly T[], num: number): [newFrom: T[], newTo: T[]] {\n    // if num is positive then elements are shifted from left-to-right, if negative then right-to-left\n    const allElements = leftArray.concat(rightArray);\n    const newLeftLength = leftArray.length - num;\n\n    if (newLeftLength <= 0) {\n        return [[], allElements];\n    } else if (newLeftLength >= allElements.length) {\n        return [allElements, []];\n    }\n\n    const sliceIndex = allElements.length - newLeftLength;\n\n    return [allElements.slice(0, -sliceIndex), allElements.slice(-sliceIndex)];\n}\n"]},"metadata":{},"sourceType":"module"}