{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __rest } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Classes as CoreClasses, Utils as CoreUtils, mergeRefs, Portal } from \"@blueprintjs/core\";\nimport * as Classes from \"./classes\";\nimport { Popover2 } from \"./popover2\";\nimport { Tooltip2Context, Tooltip2Provider } from \"./tooltip2Context\";\nexport var ContextMenu2 = React.forwardRef(function (props, userRef) {\n  var _a;\n\n  var _b;\n\n  var className = props.className,\n      children = props.children,\n      content = props.content,\n      _c = props.disabled,\n      disabled = _c === void 0 ? false : _c,\n      onContextMenu = props.onContextMenu,\n      popoverProps = props.popoverProps,\n      _d = props.tagName,\n      tagName = _d === void 0 ? \"div\" : _d,\n      restProps = __rest(props, [\"className\", \"children\", \"content\", \"disabled\", \"onContextMenu\", \"popoverProps\", \"tagName\"]); // ancestor Tooltip2Context state doesn't affect us since we don't care about parent ContextMenu2s, we only want to\n  // force disable parent Tooltip2s in certain cases through dispatching actions\n  // N.B. any calls to this dispatch function will be no-ops if there is no Tooltip2Provider ancestor of this component\n\n\n  var _e = React.useContext(Tooltip2Context),\n      tooltipCtxDispatch = _e[1]; // click target offset relative to the viewport (e.clientX/clientY), since the target will be rendered in a Portal\n\n\n  var _f = React.useState(undefined),\n      targetOffset = _f[0],\n      setTargetOffset = _f[1]; // hold a reference to the click mouse event to pass to content/child render functions\n\n\n  var _g = React.useState(),\n      mouseEvent = _g[0],\n      setMouseEvent = _g[1];\n\n  var _h = React.useState(false),\n      isOpen = _h[0],\n      setIsOpen = _h[1]; // we need a ref on the child element (or the wrapper we generate) to check for dark theme\n\n\n  var childRef = React.useRef(null); // If disabled prop is changed, we don't want our old context menu to stick around.\n  // If it has just been enabled (disabled = false), then the menu ought to be opened by\n  // a new mouse event. Users should not be updating this prop in the onContextMenu callback\n  // for this component (that will lead to unpredictable behavior).\n\n  React.useEffect(function () {\n    setIsOpen(false);\n    tooltipCtxDispatch({\n      type: \"RESET_DISABLED_STATE\"\n    });\n  }, [disabled]);\n  var cancelContextMenu = React.useCallback(function (e) {\n    return e.preventDefault();\n  }, []);\n  var handlePopoverInteraction = React.useCallback(function (nextOpenState) {\n    if (!nextOpenState) {\n      setIsOpen(false);\n      setMouseEvent(undefined);\n      tooltipCtxDispatch({\n        type: \"RESET_DISABLED_STATE\"\n      });\n    }\n  }, []); // Popover2 should attach its ref to the virtual target we render inside a Portal, not the \"inline\" child target\n\n  var renderTarget = React.useCallback(function (_a) {\n    var ref = _a.ref;\n    return React.createElement(Portal, null, React.createElement(\"div\", {\n      className: Classes.CONTEXT_MENU2_VIRTUAL_TARGET,\n      style: targetOffset,\n      ref: ref\n    }));\n  }, [targetOffset]); // if the menu was just opened, we should check for dark theme (but don't do this on every render)\n\n  var isDarkTheme = React.useMemo(function () {\n    return CoreUtils.isDarkTheme(childRef.current);\n  }, [childRef, isOpen]); // only render the popover if there is content in the context menu;\n  // this avoid doing unnecessary rendering & computation\n\n  var contentProps = {\n    isOpen: isOpen,\n    mouseEvent: mouseEvent,\n    targetOffset: targetOffset\n  };\n  var menu = disabled ? undefined : CoreUtils.isFunction(content) ? content(contentProps) : content;\n  var maybePopover = menu === undefined ? undefined : React.createElement(Popover2, __assign({}, popoverProps, {\n    content: // this prevents right-clicking inside our context menu\n    React.createElement(\"div\", {\n      onContextMenu: cancelContextMenu\n    }, menu),\n    enforceFocus: false,\n    // Generate key based on offset so that a new Popover instance is created\n    // when offset changes, to force recomputing position.\n    key: getPopoverKey(targetOffset),\n    hasBackdrop: true,\n    backdropProps: {\n      className: Classes.CONTEXT_MENU2_BACKDROP\n    },\n    isOpen: isOpen,\n    minimal: true,\n    onInteraction: handlePopoverInteraction,\n    popoverClassName: classNames(Classes.CONTEXT_MENU2_POPOVER2, popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.popoverClassName, (_a = {}, _a[CoreClasses.DARK] = isDarkTheme, _a)),\n    placement: \"right-start\",\n    positioningStrategy: \"fixed\",\n    rootBoundary: \"viewport\",\n    renderTarget: renderTarget,\n    transitionDuration: (_b = popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.transitionDuration) !== null && _b !== void 0 ? _b : 100\n  }));\n  var handleContextMenu = React.useCallback(function (e) {\n    // support nested menus (inner menu target would have called preventDefault())\n    if (e.defaultPrevented) {\n      return;\n    } // If disabled, we should avoid this extra work.\n    // Otherwise: if using the child or content function APIs, we need to make sure contentProps gets updated,\n    // so we handle the event regardless of whether the consumer returned an undefined menu.\n\n\n    var shouldHandleEvent = !disabled && (CoreUtils.isFunction(children) || CoreUtils.isFunction(content) || maybePopover !== undefined);\n\n    if (shouldHandleEvent) {\n      e.preventDefault();\n      e.persist();\n      setMouseEvent(e);\n      setTargetOffset({\n        left: e.clientX,\n        top: e.clientY\n      });\n      setIsOpen(true);\n      tooltipCtxDispatch({\n        type: \"FORCE_DISABLED_STATE\"\n      });\n    }\n\n    onContextMenu === null || onContextMenu === void 0 ? void 0 : onContextMenu(e);\n  }, [onContextMenu, disabled]);\n  var containerClassName = classNames(className, Classes.CONTEXT_MENU2);\n  var child = CoreUtils.isFunction(children) ? children({\n    className: containerClassName,\n    contentProps: contentProps,\n    onContextMenu: handleContextMenu,\n    popover: maybePopover,\n    ref: childRef\n  }) : React.createElement(React.Fragment, null, maybePopover, React.createElement(tagName, __assign({\n    className: containerClassName,\n    onContextMenu: handleContextMenu,\n    ref: mergeRefs(childRef, userRef)\n  }, restProps), children)); // force descendant Tooltip2s to be disabled when this context menu is open\n\n  return React.createElement(Tooltip2Provider, {\n    forceDisable: isOpen\n  }, child);\n});\nContextMenu2.displayName = \"Blueprint.ContextMenu2\";\n\nfunction getPopoverKey(targetOffset) {\n  return targetOffset === undefined ? \"default\" : \"\".concat(targetOffset.left, \"x\").concat(targetOffset.top);\n}","map":{"version":3,"mappings":"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","names":["classNames","React","Classes","CoreClasses","Utils","CoreUtils","mergeRefs","Portal","Popover2","Tooltip2Context","Tooltip2Provider","ContextMenu2","forwardRef","props","userRef","children","content","_c","disabled","onContextMenu","popoverProps","_d","tagName","restProps","useContext","tooltipCtxDispatch","useState","undefined","targetOffset","setTargetOffset","mouseEvent","setMouseEvent","isOpen","setIsOpen","childRef","useRef","useEffect","type","cancelContextMenu","useCallback","e","preventDefault","handlePopoverInteraction","nextOpenState","renderTarget","_a","ref","className","CONTEXT_MENU2_VIRTUAL_TARGET","style","isDarkTheme","useMemo","current","contentProps","menu","isFunction","maybePopover","__assign","enforceFocus","key","getPopoverKey","hasBackdrop","backdropProps","CONTEXT_MENU2_BACKDROP","minimal","onInteraction","popoverClassName","CONTEXT_MENU2_POPOVER2","DARK","placement","positioningStrategy","rootBoundary","transitionDuration","_b","handleContextMenu","defaultPrevented","shouldHandleEvent","persist","left","clientX","top","clientY","containerClassName","CONTEXT_MENU2","child","popover","createElement","forceDisable","displayName","concat"],"sources":["/home/administrator/Рабочий стол/inform48-react/inform48/node_modules/@blueprintjs/popover2/src/contextMenu2.tsx"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport {\n    Classes as CoreClasses,\n    Utils as CoreUtils,\n    IOverlayLifecycleProps,\n    mergeRefs,\n    Portal,\n    Props,\n} from \"@blueprintjs/core\";\n\nimport * as Classes from \"./classes\";\nimport { Popover2, Popover2Props } from \"./popover2\";\nimport { Popover2TargetProps } from \"./popover2SharedProps\";\nimport { Tooltip2Context, Tooltip2Provider } from \"./tooltip2Context\";\n\ntype Offset = {\n    left: number;\n    top: number;\n};\n\n/**\n * Render props relevant to the _content_ of a context menu (rendered as the underlying Popover's content).\n */\nexport interface ContextMenu2ContentProps {\n    /** Whether the context menu is currently open. */\n    isOpen: boolean;\n\n    /**\n     * The computed target offset (x, y) coordinates for the context menu click event.\n     * On first render, before any context menu click event has occurred, this will be undefined.\n     */\n    targetOffset: Offset | undefined;\n\n    /** The context menu click event. If isOpen is false, this will be undefined. */\n    mouseEvent: React.MouseEvent<HTMLElement> | undefined;\n}\n\n/** @deprecated use ContextMenu2ContentProps */\nexport type ContextMenu2RenderProps = ContextMenu2ContentProps;\n\n/**\n * Render props for advanced usage of ContextMenu.\n */\nexport interface ContextMenu2ChildrenProps {\n    /** Context menu container element class */\n    className: string;\n\n    /** Render props relevant to the content of this context menu */\n    contentProps: ContextMenu2ContentProps;\n\n    /** Context menu handler which implements the custom context menu interaction */\n    onContextMenu: React.MouseEventHandler<HTMLElement>;\n\n    /** Popover element rendered by ContextMenu, used to establish a click target to position the menu */\n    popover: JSX.Element | undefined;\n\n    /** DOM ref for the context menu target, used to detect dark theme */\n    ref: React.Ref<any>;\n}\n\nexport interface ContextMenu2Props\n    extends Omit<React.HTMLAttributes<HTMLElement>, \"children\" | \"className\" | \"onContextMenu\">,\n        React.RefAttributes<any>,\n        Props {\n    /**\n     * Menu content. This will usually be a Blueprint `<Menu>` component.\n     * This optionally functions as a render prop so you can use component state to render content.\n     */\n    content: JSX.Element | ((props: ContextMenu2ContentProps) => JSX.Element | undefined) | undefined;\n\n    /**\n     * The context menu target. This may optionally be a render function so you can use\n     * component state to render the target.\n     */\n    children: React.ReactNode | ((props: ContextMenu2ChildrenProps) => React.ReactElement);\n\n    /**\n     * Whether the context menu is disabled.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * An optional context menu event handler. This can be useful if you want to do something with the\n     * mouse event unrelated to rendering the context menu itself, especially if that involves setting\n     * React state (which is an error to do in the render code path of this component).\n     */\n    onContextMenu?: React.MouseEventHandler<HTMLElement>;\n\n    /**\n     * A limited subset of props to forward along to the popover generated by this component.\n     */\n    popoverProps?: IOverlayLifecycleProps &\n        Pick<Popover2Props, \"popoverClassName\" | \"transitionDuration\" | \"popoverRef\">;\n\n    /**\n     * HTML tag to use for container element. Only used if this component's children are specified as\n     * React node(s), not when it is a render function (in that case, you get to render whatever tag\n     * you wish).\n     *\n     * @default \"div\"\n     */\n    tagName?: keyof JSX.IntrinsicElements;\n}\n\nexport const ContextMenu2: React.FC<ContextMenu2Props> = React.forwardRef<any, ContextMenu2Props>((props, userRef) => {\n    const {\n        className,\n        children,\n        content,\n        disabled = false,\n        onContextMenu,\n        popoverProps,\n        tagName = \"div\",\n        ...restProps\n    } = props;\n\n    // ancestor Tooltip2Context state doesn't affect us since we don't care about parent ContextMenu2s, we only want to\n    // force disable parent Tooltip2s in certain cases through dispatching actions\n    // N.B. any calls to this dispatch function will be no-ops if there is no Tooltip2Provider ancestor of this component\n    const [, tooltipCtxDispatch] = React.useContext(Tooltip2Context);\n    // click target offset relative to the viewport (e.clientX/clientY), since the target will be rendered in a Portal\n    const [targetOffset, setTargetOffset] = React.useState<Offset | undefined>(undefined);\n    // hold a reference to the click mouse event to pass to content/child render functions\n    const [mouseEvent, setMouseEvent] = React.useState<React.MouseEvent<HTMLElement>>();\n    const [isOpen, setIsOpen] = React.useState<boolean>(false);\n    // we need a ref on the child element (or the wrapper we generate) to check for dark theme\n    const childRef = React.useRef<HTMLDivElement>(null);\n\n    // If disabled prop is changed, we don't want our old context menu to stick around.\n    // If it has just been enabled (disabled = false), then the menu ought to be opened by\n    // a new mouse event. Users should not be updating this prop in the onContextMenu callback\n    // for this component (that will lead to unpredictable behavior).\n    React.useEffect(() => {\n        setIsOpen(false);\n        tooltipCtxDispatch({ type: \"RESET_DISABLED_STATE\" });\n    }, [disabled]);\n\n    const cancelContextMenu = React.useCallback((e: React.SyntheticEvent<HTMLDivElement>) => e.preventDefault(), []);\n\n    const handlePopoverInteraction = React.useCallback((nextOpenState: boolean) => {\n        if (!nextOpenState) {\n            setIsOpen(false);\n            setMouseEvent(undefined);\n            tooltipCtxDispatch({ type: \"RESET_DISABLED_STATE\" });\n        }\n    }, []);\n\n    // Popover2 should attach its ref to the virtual target we render inside a Portal, not the \"inline\" child target\n    const renderTarget = React.useCallback(\n        ({ ref }: Popover2TargetProps) => (\n            <Portal>\n                <div className={Classes.CONTEXT_MENU2_VIRTUAL_TARGET} style={targetOffset} ref={ref} />\n            </Portal>\n        ),\n        [targetOffset],\n    );\n\n    // if the menu was just opened, we should check for dark theme (but don't do this on every render)\n    const isDarkTheme = React.useMemo(() => CoreUtils.isDarkTheme(childRef.current), [childRef, isOpen]);\n\n    // only render the popover if there is content in the context menu;\n    // this avoid doing unnecessary rendering & computation\n    const contentProps: ContextMenu2ContentProps = { isOpen, mouseEvent, targetOffset };\n    const menu = disabled ? undefined : CoreUtils.isFunction(content) ? content(contentProps) : content;\n    const maybePopover =\n        menu === undefined ? undefined : (\n            <Popover2\n                {...popoverProps}\n                content={\n                    // this prevents right-clicking inside our context menu\n                    <div onContextMenu={cancelContextMenu}>{menu}</div>\n                }\n                enforceFocus={false}\n                // Generate key based on offset so that a new Popover instance is created\n                // when offset changes, to force recomputing position.\n                key={getPopoverKey(targetOffset)}\n                hasBackdrop={true}\n                backdropProps={{ className: Classes.CONTEXT_MENU2_BACKDROP }}\n                isOpen={isOpen}\n                minimal={true}\n                onInteraction={handlePopoverInteraction}\n                popoverClassName={classNames(Classes.CONTEXT_MENU2_POPOVER2, popoverProps?.popoverClassName, {\n                    [CoreClasses.DARK]: isDarkTheme,\n                })}\n                placement=\"right-start\"\n                positioningStrategy=\"fixed\"\n                rootBoundary=\"viewport\"\n                renderTarget={renderTarget}\n                transitionDuration={popoverProps?.transitionDuration ?? 100}\n            />\n        );\n\n    const handleContextMenu = React.useCallback(\n        (e: React.MouseEvent<HTMLElement>) => {\n            // support nested menus (inner menu target would have called preventDefault())\n            if (e.defaultPrevented) {\n                return;\n            }\n\n            // If disabled, we should avoid this extra work.\n            // Otherwise: if using the child or content function APIs, we need to make sure contentProps gets updated,\n            // so we handle the event regardless of whether the consumer returned an undefined menu.\n            const shouldHandleEvent =\n                !disabled &&\n                (CoreUtils.isFunction(children) || CoreUtils.isFunction(content) || maybePopover !== undefined);\n\n            if (shouldHandleEvent) {\n                e.preventDefault();\n                e.persist();\n                setMouseEvent(e);\n                setTargetOffset({ left: e.clientX, top: e.clientY });\n                setIsOpen(true);\n                tooltipCtxDispatch({ type: \"FORCE_DISABLED_STATE\" });\n            }\n\n            onContextMenu?.(e);\n        },\n        [onContextMenu, disabled],\n    );\n\n    const containerClassName = classNames(className, Classes.CONTEXT_MENU2);\n\n    const child = CoreUtils.isFunction(children) ? (\n        children({\n            className: containerClassName,\n            contentProps,\n            onContextMenu: handleContextMenu,\n            popover: maybePopover,\n            ref: childRef,\n        })\n    ) : (\n        <>\n            {maybePopover}\n            {React.createElement<React.HTMLAttributes<any>>(\n                tagName,\n                {\n                    className: containerClassName,\n                    onContextMenu: handleContextMenu,\n                    ref: mergeRefs(childRef, userRef),\n                    ...restProps,\n                },\n                children,\n            )}\n        </>\n    );\n\n    // force descendant Tooltip2s to be disabled when this context menu is open\n    return <Tooltip2Provider forceDisable={isOpen}>{child}</Tooltip2Provider>;\n});\nContextMenu2.displayName = \"Blueprint.ContextMenu2\";\n\nfunction getPopoverKey(targetOffset: Offset | undefined) {\n    return targetOffset === undefined ? \"default\" : `${targetOffset.left}x${targetOffset.top}`;\n}\n"]},"metadata":{},"sourceType":"module"}