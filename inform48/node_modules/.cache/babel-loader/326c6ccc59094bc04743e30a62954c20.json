{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __rest } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Classes as CoreClasses, Utils as CoreUtils, mergeRefs, Portal } from \"@blueprintjs/core\";\nimport * as Classes from \"./classes\";\nimport { Popover2 } from \"./popover2\";\nimport { Tooltip2Context, Tooltip2Provider } from \"./tooltip2Context\";\nexport var ContextMenu2 = React.forwardRef(function (props, userRef) {\n  var _a;\n\n  var _b;\n\n  var className = props.className,\n      children = props.children,\n      content = props.content,\n      _c = props.disabled,\n      disabled = _c === void 0 ? false : _c,\n      onContextMenu = props.onContextMenu,\n      popoverProps = props.popoverProps,\n      _d = props.tagName,\n      tagName = _d === void 0 ? \"div\" : _d,\n      restProps = __rest(props, [\"className\", \"children\", \"content\", \"disabled\", \"onContextMenu\", \"popoverProps\", \"tagName\"]); // ancestor Tooltip2Context state doesn't affect us since we don't care about parent ContextMenu2s, we only want to\n  // force disable parent Tooltip2s in certain cases through dispatching actions\n  // N.B. any calls to this dispatch function will be no-ops if there is no Tooltip2Provider ancestor of this component\n\n\n  var _e = React.useContext(Tooltip2Context),\n      tooltipCtxDispatch = _e[1]; // click target offset relative to the viewport (e.clientX/clientY), since the target will be rendered in a Portal\n\n\n  var _f = React.useState(undefined),\n      targetOffset = _f[0],\n      setTargetOffset = _f[1]; // hold a reference to the click mouse event to pass to content/child render functions\n\n\n  var _g = React.useState(),\n      mouseEvent = _g[0],\n      setMouseEvent = _g[1];\n\n  var _h = React.useState(false),\n      isOpen = _h[0],\n      setIsOpen = _h[1]; // we need a ref on the child element (or the wrapper we generate) to check for dark theme\n\n\n  var childRef = React.useRef(null); // If disabled prop is changed, we don't want our old context menu to stick around.\n  // If it has just been enabled (disabled = false), then the menu ought to be opened by\n  // a new mouse event. Users should not be updating this prop in the onContextMenu callback\n  // for this component (that will lead to unpredictable behavior).\n\n  React.useEffect(function () {\n    setIsOpen(false);\n    tooltipCtxDispatch({\n      type: \"RESET_DISABLED_STATE\"\n    });\n  }, [disabled]);\n  var cancelContextMenu = React.useCallback(function (e) {\n    return e.preventDefault();\n  }, []);\n  var handlePopoverInteraction = React.useCallback(function (nextOpenState) {\n    if (!nextOpenState) {\n      setIsOpen(false);\n      setMouseEvent(undefined);\n      tooltipCtxDispatch({\n        type: \"RESET_DISABLED_STATE\"\n      });\n    }\n  }, []); // Popover2 should attach its ref to the virtual target we render inside a Portal, not the \"inline\" child target\n\n  var renderTarget = React.useCallback(function (_a) {\n    var ref = _a.ref;\n    return React.createElement(Portal, null, React.createElement(\"div\", {\n      className: Classes.CONTEXT_MENU2_VIRTUAL_TARGET,\n      style: targetOffset,\n      ref: ref\n    }));\n  }, [targetOffset]); // if the menu was just opened, we should check for dark theme (but don't do this on every render)\n\n  var isDarkTheme = React.useMemo(function () {\n    return CoreUtils.isDarkTheme(childRef.current);\n  }, [childRef, isOpen]); // only render the popover if there is content in the context menu;\n  // this avoid doing unnecessary rendering & computation\n\n  var contentProps = {\n    isOpen: isOpen,\n    mouseEvent: mouseEvent,\n    targetOffset: targetOffset\n  };\n  var menu = disabled ? undefined : CoreUtils.isFunction(content) ? content(contentProps) : content;\n  var maybePopover = menu === undefined ? undefined : React.createElement(Popover2, __assign({}, popoverProps, {\n    content: // this prevents right-clicking inside our context menu\n    React.createElement(\"div\", {\n      onContextMenu: cancelContextMenu\n    }, menu),\n    enforceFocus: false,\n    // Generate key based on offset so that a new Popover instance is created\n    // when offset changes, to force recomputing position.\n    key: getPopoverKey(targetOffset),\n    hasBackdrop: true,\n    backdropProps: {\n      className: Classes.CONTEXT_MENU2_BACKDROP\n    },\n    isOpen: isOpen,\n    minimal: true,\n    onInteraction: handlePopoverInteraction,\n    popoverClassName: classNames(Classes.CONTEXT_MENU2_POPOVER2, popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.popoverClassName, (_a = {}, _a[CoreClasses.DARK] = isDarkTheme, _a)),\n    placement: \"right-start\",\n    positioningStrategy: \"fixed\",\n    rootBoundary: \"viewport\",\n    renderTarget: renderTarget,\n    transitionDuration: (_b = popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.transitionDuration) !== null && _b !== void 0 ? _b : 100\n  }));\n  var handleContextMenu = React.useCallback(function (e) {\n    // support nested menus (inner menu target would have called preventDefault())\n    if (e.defaultPrevented) {\n      return;\n    } // If disabled, we should avoid this extra work.\n    // Otherwise: if using the child or content function APIs, we need to make sure contentProps gets updated,\n    // so we handle the event regardless of whether the consumer returned an undefined menu.\n\n\n    var shouldHandleEvent = !disabled && (CoreUtils.isFunction(children) || CoreUtils.isFunction(content) || maybePopover !== undefined);\n\n    if (shouldHandleEvent) {\n      e.preventDefault();\n      e.persist();\n      setMouseEvent(e);\n      setTargetOffset({\n        left: e.clientX,\n        top: e.clientY\n      });\n      setIsOpen(true);\n      tooltipCtxDispatch({\n        type: \"FORCE_DISABLED_STATE\"\n      });\n    }\n\n    onContextMenu === null || onContextMenu === void 0 ? void 0 : onContextMenu(e);\n  }, [onContextMenu, disabled]);\n  var containerClassName = classNames(className, Classes.CONTEXT_MENU2);\n  var child = CoreUtils.isFunction(children) ? children({\n    className: containerClassName,\n    contentProps: contentProps,\n    onContextMenu: handleContextMenu,\n    popover: maybePopover,\n    ref: childRef\n  }) : React.createElement(React.Fragment, null, maybePopover, React.createElement(tagName, __assign({\n    className: containerClassName,\n    onContextMenu: handleContextMenu,\n    ref: mergeRefs(childRef, userRef)\n  }, restProps), children)); // force descendant Tooltip2s to be disabled when this context menu is open\n\n  return React.createElement(Tooltip2Provider, {\n    forceDisable: isOpen\n  }, child);\n});\nContextMenu2.displayName = \"Blueprint.ContextMenu2\";\n\nfunction getPopoverKey(targetOffset) {\n  return targetOffset === undefined ? \"default\" : \"\".concat(targetOffset.left, \"x\").concat(targetOffset.top);\n}","map":null,"metadata":{},"sourceType":"module"}